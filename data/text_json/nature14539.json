{
  "filename": "nature14539.pdf",
  "num_pages": 9,
  "pages": [
    "1Facebook AI Research, 770 Broadway, New York, New York 10003 USA. 2New York University, 715 Broadway, New York, New York 10003, USA. 3Department of Computer Science and Operations \nResearch Université de Montréal, Pavillon André-Aisenstadt, PO Box 6128  Centre-Ville STN Montréal, Quebec H3C 3J7, Canada. 4Google, 1600 Amphitheatre Parkway, Mountain View, California \n94043, USA. 5Department of Computer Science, University of Toronto, 6 King’s College Road, Toronto, Ontario M5S 3G4, Canada.\nM\nachine-learning technology powers many aspects of modern \nsociety: from web searches to content filtering on social net­\nworks to recommendations on e-commerce websites, and \nit is increasingly present in consumer products such as cameras and \nsmartphones. Machine-learning systems are used to identify objects \nin images, transcribe speech into text, match news items, posts or \nproducts with users’ interests, and select relevant results of search. \nIncreasingly, these applications make use of a class of techniques called \ndeep learning. \nConventional machine-learning techniques were limited in their \nability to process natural data in their raw form. For decades, con­\nstructing a pattern-recognition or machine-learning system required \ncareful engineering and considerable domain expertise to design a fea­\nture extractor that transformed the raw data (such as the pixel values \nof an image) into a suitable internal representation or feature vector \nfrom which the learning subsystem, often a classifier, could detect or \nclassify patterns in the input. \nRepresentation learning is a set of methods that allows a machine to \nbe fed with raw data and to automatically discover the representations \nneeded for detection or classification. Deep-learning methods are \nrepresentation-learning methods with multiple levels of representa­\ntion, obtained by composing simple but non-linear modules that each \ntransform the representation at one level (starting with the raw input) \ninto a representation at a higher, slightly more abstract level. With the \ncomposition of enough such transformations, very complex functions \ncan be learned. For classification tasks, higher layers of representation \namplify aspects of the input that are important for discrimination and \nsuppress irrelevant variations. An image, for example, comes in the \nform of an array of pixel values, and the learned features in the first \nlayer of representation typically represent the presence or absence of \nedges at particular orientations and locations in the image. The second \nlayer typically detects motifs by spotting particular arrangements of \nedges, regardless of small variations in the edge positions. The third \nlayer may assemble motifs into larger combinations that correspond \nto parts of familiar objects, and subsequent layers would detect objects \nas combinations of these parts. The key aspect of deep learning is that \nthese layers of features are not designed by human engineers: they \nare learned from data using a general-purpose learning procedure. \nDeep learning is making major advances in solving problems that \nhave resisted the best attempts of the artificial intelligence commu­\nnity for many years. It has turned out to be very good at discovering \nintricate structures in high-dimensional data and is therefore applica­\nble to many domains of science, business and government. In addition \nto beating records in image recognition1–4 and speech recognition5–7, it \nhas beaten other machine-learning techniques at predicting the activ­\nity of potential drug molecules8, analysing particle accelerator data9,10, \nreconstructing brain circuits11, and predicting the effects of mutations \nin non-coding DNA on gene expression and disease12,13. Perhaps more \nsurprisingly, deep learning has produced extremely promising results \nfor various tasks in natural language understanding14, particularly \ntopic classification, sentiment analysis, question answering15 and lan­\nguage translation16,17. \nWe think that deep learning will have many more successes in the \nnear future because it requires very little engineering by hand, so it \ncan easily take advantage of increases in the amount of available com­\nputation and data. New learning algorithms and architectures that are \ncurrently being developed for deep neural networks will only acceler­\nate this progress. \nSupervised learning \nThe most common form of machine learning, deep or not, is super­\nvised learning. Imagine that we want to build a system that can classify \nimages as containing, say, a house, a car, a person or a pet. We first \ncollect a large data set of images of houses, cars, people and pets, each \nlabelled with its category. During training, the machine is shown an \nimage and produces an output in the form of a vector of scores, one \nfor each category. We want the desired category to have the highest \nscore of all categories, but this is unlikely to happen before training. \nWe compute an objective function that measures the error (or dis­\ntance) between the output scores and the desired pattern of scores. The \nmachine then modifies its internal adjustable parameters to reduce \nthis error. These adjustable parameters, often called weights, are real \nnumbers that can be seen as ‘knobs’ that define the input–output func­\ntion of the machine. In a typical deep-learning system, there may be \nhundreds of millions of these adjustable weights, and hundreds of \nmillions of labelled examples with which to train the machine. \nTo properly adjust the weight vector, the learning algorithm com­\nputes a gradient vector that, for each weight, indicates by what amount \nthe error would increase or decrease if the weight were increased by a \ntiny amount. The weight vector is then adjusted in the opposite direc­\ntion to the gradient vector. \nThe objective function, averaged over all the training examples, can \nDeep learning allows computational models that are composed of multiple processing layers to learn representations of \ndata with multiple levels of abstraction. These methods have dramatically improved the state-of-the-art in speech rec­\nognition, visual object recognition, object detection and many other domains such as drug discovery and genomics. Deep \nlearning discovers intricate structure in large data sets by using the backpropagation algorithm to indicate how a machine \nshould change its internal parameters that are used to compute the representation in each layer from the representation in \nthe previous layer. Deep convolutional nets have brought about breakthroughs in processing images, video, speech and \naudio, whereas recurrent nets have shone light on sequential data such as text and speech. \nDeep learning\nYann LeCun1,2, Yoshua Bengio3 & Geoffrey Hinton4,5\n4 3 6  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\ndoi:10.1038/nature14539\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "be seen as a kind of hilly landscape in the high-dimensional space of \nweight values. The negative gradient vector indicates the direction \nof steepest descent in this landscape, taking it closer to a minimum, \nwhere the output error is low on average. \nIn practice, most practitioners use a procedure called stochastic \ngradient descent (SGD). This consists of showing the input vector \nfor a few examples, computing the outputs and the errors, computing \nthe average gradient for those examples, and adjusting the weights \naccordingly. The process is repeated for many small sets of examples \nfrom the training set until the average of the objective function stops \ndecreasing. It is called stochastic because each small set of examples \ngives a noisy estimate of the average gradient over all examples. This \nsimple procedure usually finds a good set of weights surprisingly \nquickly when compared with far more elaborate optimization tech­\nniques18. After training, the performance of the system is measured \non a different set of examples called a test set. This serves to test the \ngeneralization ability of the machine — its ability to produce sensible \nanswers on new inputs that it has never seen during training. \nMany of the current practical applications of machine learning use \nlinear classifiers on top of hand-engineered features. A two-class linear \nclassifier computes a weighted sum of the feature vector components. \nIf the weighted sum is above a threshold, the input is classified as \nbelonging to a particular category. \nSince the 1960s we have known that linear classifiers can only carve \ntheir input space into very simple regions, namely half-spaces sepa­\nrated by a hyperplane19. But problems such as image and speech recog­\nnition require the input–output function to be insensitive to irrelevant \nvariations of the input, such as variations in position, orientation or \nillumination of an object, or variations in the pitch or accent of speech, \nwhile being very sensitive to particular minute variations (for example, \nthe difference between a white wolf and a breed of wolf-like white \ndog called a Samoyed). At the pixel level, images of two Samoyeds in \ndifferent poses and in different environments may be very different \nfrom each other, whereas two images of a Samoyed and a wolf in the \nsame position and on similar backgrounds may be very similar to each \nother. A linear classifier, or any other ‘shallow’ classifier operating on \nFigure 1 | Multilayer neural networks and backpropagation.  a, A multi-\nlayer neural network (shown by the connected dots) can distort the input \nspace to make the classes of data (examples of which are on the red and \nblue lines) linearly separable. Note how a regular grid (shown on the left) \nin input space is also transformed (shown in the middle panel) by hidden \nunits. This is an illustrative example with only two input units, two hidden \nunits and one output unit, but the networks used for object recognition \nor natural language processing contain tens or hundreds of thousands of \nunits. Reproduced with permission from C. Olah (http://colah.github.io/). \nb, The chain rule of derivatives tells us how two small effects (that of a small \nchange of x on y, and that of y on z) are composed. A small change Δx in \nx gets transformed first into a small change Δy in y by getting multiplied \nby ∂y/∂x (that is, the definition of partial derivative). Similarly, the change \nΔy creates a change Δz in z. Substituting one equation into the other \ngives the chain rule of derivatives — how Δx gets turned into Δz through \nmultiplication by the product of ∂y/∂x and ∂z/∂x. It also works when x, \ny and z are vectors (and the derivatives are Jacobian matrices). c, The \nequations used for computing the forward pass in a neural net with two \nhidden layers and one output layer, each constituting a module through \nwhich one can backpropagate gradients. At each layer, we first compute \nthe total input z to each unit, which is a weighted sum of the outputs of \nthe units in the layer below. Then a non-linear function f(.) is applied to \nz to get the output of the unit. For simplicity, we have omitted bias terms. \nThe non-linear functions used in neural networks include the rectified \nlinear unit (ReLU) f(z) = max(0,z), commonly used in recent years, as \nwell as the more conventional sigmoids, such as the hyberbolic tangent, \nf(z) = (exp(z) − exp(−z))/(exp(z) + exp(−z)) and logistic function logistic, \nf(z) = 1/(1 + exp(−z)). d, The equations used for computing the backward \npass. At each hidden layer we compute the error derivative with respect to \nthe output of each unit, which is a weighted sum of the error derivatives \nwith respect to the total inputs to the units in the layer above. We then \nconvert the error derivative with respect to the output into the error \nderivative with respect to the input by multiplying it by the gradient of f(z). \nAt the output layer, the error derivative with respect to the output of a unit \nis computed by differentiating the cost function. This gives yl − tl if the cost \nfunction for unit l is 0.5(yl − tl)2, where tl is the target value. Once the ∂E/∂zk \nis known, the error-derivative for the weight wjk on the connection from \nunit j in the layer below is just yj ∂E/∂zk.\nInput\n(2)\nOutput\n(1 sigmoid)\nHidden\n(2 sigmoid)\na\nb\nd\nc\ny\ny\nx\ny\nx\n\n\n=\ny\nz\n\n\nx\ny\n\n\nz\ny\nz\nz\ny\n\n\n=\nΔ\nΔ\nΔ\nΔ\nΔ\nΔ\nz\ny\nz\nx\ny\nx\n\n\n\n\n=\nx\nz\ny\nz\nx\nx\ny\n\n\n\n\n\n\n=\nCompare outputs with correct \nanswer to get error derivatives\nj\nk\nE\nyl\n=yl\ntl\nE\nzl\n= E\nyl\nyl\nzl\nl\nE\nyj\n=\nwjk\nE\nzk\nE\nzj\n= E\nyj\nyj\nzj\nE\nyk\n=\nwkl\nE\nzl\nE\nzk\n= E\nyk\nyk\nzk\nwkl\nwjk\nwij\ni\nj\nk\nyl = f (zl)\nzl =\nwkl yk\nl\nyj = f (zj)\nzj =\nwij xi\nyk = f (zk)\nzk =\nwjk yj\nOutput units \nInput units \nHidden units H2 \nHidden units H1 \nwkl\nwjk\nwij\nk  H2\nk  H2\nI  out\nj  H1\ni  Input\ni\n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 3 7\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "raw pixels could not possibly distinguish the latter two, while putting \nthe former two in the same category. This is why shallow classifiers \nrequire a good feature extractor that solves the selectivity–invariance \ndilemma — one that produces representations that are selective to \nthe aspects of the image that are important for discrimination, but \nthat are invariant to irrelevant aspects such as the pose of the animal. \nTo make classifiers more powerful, one can use generic non-linear \nfeatures, as with kernel methods20, but generic features such as those \narising with the Gaussian kernel do not allow the learner to general­\nize well far from the training examples21. The conventional option is \nto hand design good feature extractors, which requires a consider­\nable amount of engineering skill and domain expertise. But this can \nall be avoided if good features can be learned automatically using a \ngeneral-purpose learning procedure. This is the key advantage of \ndeep learning. \nA deep-learning architecture is a multilayer stack of simple mod­\nules, all (or most) of which are subject to learning, and many of which \ncompute non-linear input–output mappings. Each module in the \nstack transforms its input to increase both the selectivity and the \ninvariance of the representation. With multiple non-linear layers, say \na depth of 5 to 20, a system can implement extremely intricate func­\ntions of its inputs that are simultaneously sensitive to minute details \n— distinguishing Samoyeds from white wolves — and insensitive to \nlarge irrelevant variations such as the background, pose, lighting and \nsurrounding objects. \nBackpropagation to train multilayer architectures \nFrom the earliest days of pattern recognition22,23, the aim of research­\ners has been to replace hand-engineered features with trainable \nmultilayer networks, but despite its simplicity, the solution was not \nwidely understood until the mid 1980s. As it turns out, multilayer \narchitectures can be trained by simple stochastic gradient descent. \nAs long as the modules are relatively smooth functions of their inputs \nand of their internal weights, one can compute gradients using the \nbackpropagation procedure. The idea that this could be done, and \nthat it worked, was discovered independently by several different \ngroups during the 1970s and 1980s24–27.  \nThe backpropagation procedure to compute the gradient of an \nobjective function with respect to the weights of a multilayer stack \nof modules is nothing more than a practical application of the chain \nrule for derivatives. The key insight is that the derivative (or gradi­\nent) of the objective with respect to the input of a module can be \ncomputed by working backwards from the gradient with respect to \nthe output of that module (or the input of the subsequent module) \n(Fig. 1). The backpropagation equation can be applied repeatedly to \npropagate gradients through all modules, starting from the output \nat the top (where the network produces its prediction) all the way to \nthe bottom (where the external input is fed). Once these gradients \nhave been computed, it is straightforward to compute the gradients \nwith respect to the weights of each module. \nMany applications of deep learning use feedforward neural net­\nwork architectures (Fig. 1), which learn to map a fixed-size input \n(for example, an image) to a fixed-size output (for example, a prob­\nability for each of several categories). To go from one layer to the \nnext, a set of units compute a weighted sum of their inputs from the \nprevious layer and pass the result through a non-linear function. At \npresent, the most popular non-linear function is the rectified linear \nunit (ReLU), which is simply the half-wave rectifier f(z) = max(z, 0). \nIn past decades, neural nets used smoother non-linearities, such as \ntanh(z) or 1/(1 + exp(−z)), but the ReLU typically learns much faster \nin networks with many layers, allowing training of a deep supervised \nnetwork without unsupervised pre-training28. Units that are not in \nthe input or output layer are conventionally called hidden units. The \nhidden layers can be seen as distorting the input in a non-linear way \nso that categories become linearly separable by the last layer (Fig. 1). \nIn the late 1990s, neural nets and backpropagation were largely \nforsaken by the machine-learning community and ignored by the \ncomputer-vision and speech-recognition communities. It was widely \nthought that learning useful, multistage, feature extractors with lit­\ntle prior knowledge was infeasible. In particular, it was commonly \nthought that simple gradient descent would get trapped in poor local \nminima — weight configurations for which no small change would \nreduce the average error. \nIn practice, poor local minima are rarely a problem with large net­\nworks. Regardless of the initial conditions, the system nearly always \nreaches solutions of very similar quality. Recent theoretical and \nempirical results strongly suggest that local minima are not a serious \nissue in general. Instead, the landscape is packed with a combinato­\nrially large number of saddle points where the gradient is zero, and \nthe surface curves up in most dimensions and curves down in the \nFigure 2 | Inside a convolutional network.  The outputs (not the filters) \nof each layer (horizontally) of a typical convolutional network architecture \napplied to the image of a Samoyed dog (bottom left; and RGB (red, green, \nblue) inputs, bottom right). Each rectangular image is a feature map \ncorresponding to the output for one of the learned features, detected at each \nof the image positions. Information flows bottom up, with lower-level features \nacting as oriented edge detectors, and a score is computed for each image class \nin output. ReLU, rectified linear unit.\nRed\nGreen\nBlue\nSamoyed (16); Papillon (5.7); Pomeranian (2.7); Arctic fox (1.0); Eskimo dog (0.6); white wolf (0.4); Siberian husky (0.4)\nConvolutions and ReLU\nMax pooling\nMax pooling\nConvolutions and ReLU\nConvolutions and ReLU\n4 3 8  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "remainder29,30. The analysis seems to show that saddle points with \nonly a few downward curving directions are present in very large \nnumbers, but almost all of them have very similar values of the objec­\ntive function. Hence, it does not much matter which of these saddle \npoints the algorithm gets stuck at. \nInterest in deep feedforward networks was revived around 2006 \n(refs 31–34) by a group of researchers brought together by the Cana­\ndian Institute for Advanced Research (CIFAR). The researchers intro­\nduced unsupervised learning procedures that could create layers of \nfeature detectors without requiring labelled data. The objective in \nlearning each layer of feature detectors was to be able to reconstruct \nor model the activities of feature detectors (or raw inputs) in the layer \nbelow. By ‘pre-training’ several layers of progressively more complex \nfeature detectors using this reconstruction objective, the weights of a \ndeep network could be initialized to sensible values. A final layer of \noutput units could then be added to the top of the network and the \nwhole deep system could be fine-tuned using standard backpropaga­\ntion33–35. This worked remarkably well for recognizing handwritten \ndigits or for detecting pedestrians, especially when the amount of \nlabelled data was very limited36. \nThe first major application of this pre-training approach was in \nspeech recognition, and it was made possible by the advent of fast \ngraphics processing units (GPUs) that were convenient to program37 \nand allowed researchers to train networks 10 or 20 times faster. In \n2009, the approach was used to map short temporal windows of coef­\nficients extracted from a sound wave to a set of probabilities for the \nvarious fragments of speech that might be represented by the frame \nin the centre of the window. It achieved record-breaking results on a \nstandard speech recognition benchmark that used a small vocabu­\nlary38 and was quickly developed to give record-breaking results on \na large vocabulary task39. By 2012, versions of the deep net from 2009 \nwere being developed by many of the major speech groups6 and were \nalready being deployed in Android phones. For smaller data sets, \nunsupervised pre-training helps to prevent overfitting40, leading to \nsignificantly better generalization when the number of labelled exam­\nples is small, or in a transfer setting where we have lots of examples \nfor some ‘source’ tasks but very few for some ‘target’ tasks. Once deep \nlearning had been rehabilitated, it turned out that the pre-training \nstage was only needed for small data sets. \nThere was, however, one particular type of deep, feedforward net­\nwork that was much easier to train and generalized much better than \nnetworks with full connectivity between adjacent layers. This was \nthe convolutional neural network (ConvNet)41,42. It achieved many \npractical successes during the period when neural networks were out \nof favour and it has recently been widely adopted by the computer-\nvision community. \nConvolutional neural networks \nConvNets are designed to process data that come in the form of \nmultiple arrays, for example a colour image composed of three 2D \narrays containing pixel intensities in the three colour channels. Many \ndata modalities are in the form of multiple arrays: 1D for signals and \nsequences, including language; 2D for images or audio spectrograms; \nand 3D for video or volumetric images. There are four key ideas \nbehind ConvNets that take advantage of the properties of natural \nsignals: local connections, shared weights, pooling and the use of \nmany layers. \nThe architecture of a typical ConvNet (Fig. 2) is structured as a \nseries of stages. The first few stages are composed of two types of \nlayers: convolutional layers and pooling layers. Units in a convolu­\ntional layer are organized in feature maps, within which each unit \nis connected to local patches in the feature maps of the previous \nlayer through a set of weights called a filter bank. The result of this \nlocal weighted sum is then passed through a non-linearity such as a \nReLU. All units in a feature map share the same filter bank. Differ­\nent feature maps in a layer use different filter banks. The reason for \nthis architecture is twofold. First, in array data such as images, local \ngroups of values are often highly correlated, forming distinctive local \nmotifs that are easily detected. Second, the local statistics of images \nand other signals are invariant to location. In other words, if a motif \ncan appear in one part of the image, it could appear anywhere, hence \nthe idea of units at different locations sharing the same weights and \ndetecting the same pattern in different parts of the array. Mathemati­\ncally, the filtering operation performed by a feature map is a discrete \nconvolution, hence the name. \nAlthough the role of the convolutional layer is to detect local con­\njunctions of features from the previous layer, the role of the pooling \nlayer is to merge semantically similar features into one. Because the \nrelative positions of the features forming a motif can vary somewhat, \nreliably detecting the motif can be done by coarse-graining the posi­\ntion of each feature. A typical pooling unit computes the maximum \nof a local patch of units in one feature map (or in a few feature maps). \nNeighbouring pooling units take input from patches that are shifted \nby more than one row or column, thereby reducing the dimension of \nthe representation and creating an invariance to small shifts and dis­\ntortions. Two or three stages of convolution, non-linearity and pool­\ning are stacked, followed by more convolutional and fully-connected \nlayers. Backpropagating gradients through a ConvNet is as simple as \nthrough a regular deep network, allowing all the weights in all the \nfilter banks to be trained. \nDeep neural networks exploit the property that many natural sig­\nnals are compositional hierarchies, in which higher-level features \nare obtained by composing lower-level ones. In images, local combi­\nnations of edges form motifs, motifs assemble into parts, and parts \nform objects. Similar hierarchies exist in speech and text from sounds \nto phones, phonemes, syllables, words and sentences. The pooling \nallows representations to vary very little when elements in the previ­\nous layer vary in position and appearance. \nThe convolutional and pooling layers in ConvNets are directly \ninspired by the classic notions of simple cells and complex cells in \nvisual neuroscience43, and the overall architecture is reminiscent of \nthe LGN–V1–V2–V4–IT hierarchy in the visual cortex ventral path­\nway44. When ConvNet models and monkeys are shown the same pic­\nture, the activations of high-level units in the ConvNet explains half \nof the variance of random sets of 160 neurons in the monkey’s infer­\notemporal cortex45. ConvNets have their roots in the neocognitron46, \nthe architecture of which was somewhat similar, but did not have an \nend-to-end supervised-learning algorithm such as backpropagation. \nA primitive 1D ConvNet called a time-delay neural net was used for \nthe recognition of phonemes and simple words47,48. \nThere have been numerous applications of convolutional net­\nworks going back to the early 1990s, starting with time-delay neu­\nral networks for speech recognition47 and document reading42. The \ndocument reading system used a ConvNet trained jointly with a \nprobabilistic model that implemented language constraints. By the \nlate 1990s this system was reading over 10% of all the cheques in the \nUnited States. A number of ConvNet-based optical character recog­\nnition and handwriting recognition systems were later deployed by \nMicrosoft49. ConvNets were also experimented with in the early 1990s \nfor object detection in natural images, including faces and hands50,51, \nand for face recognition52. \nImage understanding with deep convolutional networks \nSince the early 2000s, ConvNets have been applied with great success to \nthe detection, segmentation and recognition of objects and regions in \nimages. These were all tasks in which labelled data was relatively abun­\ndant, such as traffic sign recognition53, the segmentation of biological \nimages54 particularly for connectomics55, and the detection of faces, \ntext, pedestrians and human bodies in natural images36,50,51,56–58. A major \nrecent practical success of ConvNets is face recognition59. \nImportantly, images can be labelled at the pixel level, which will have \napplications in technology, including autonomous mobile robots and \n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 3 9\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "self-driving cars60,61. Companies such as Mobileye and NVIDIA are \nusing such ConvNet-based methods in their upcoming vision sys­\ntems for cars. Other applications gaining importance involve natural \nlanguage understanding14 and speech recognition7. \nDespite these successes, ConvNets were largely forsaken by the \nmainstream computer-vision and machine-learning communities \nuntil the ImageNet competition in 2012. When deep convolutional \nnetworks were applied to a data set of about a million images from \nthe web that contained 1,000 different classes, they achieved spec­\ntacular results, almost halving the error rates of the best compet­\ning approaches1. This success came from the efficient use of GPUs, \nReLUs, a new regularization technique called dropout62, and tech­\nniques to generate more training examples by deforming the existing \nones. This success has brought about a revolution in computer vision; \nConvNets are now the dominant approach for almost all recognition \nand detection tasks4,58,59,63–65 and approach human performance on \nsome tasks. A recent stunning demonstration combines ConvNets \nand recurrent net modules for the generation of image captions \n(Fig. 3). \nRecent ConvNet architectures have 10 to 20 layers of ReLUs, hun­\ndreds of millions of weights, and billions of connections between \nunits. Whereas training such large networks could have taken weeks \nonly two years ago, progress in hardware, software and algorithm \nparallelization have reduced training times to a few hours. \nThe performance of ConvNet-based vision systems has caused \nmost major technology companies, including Google, Facebook, \nMicrosoft, IBM, Yahoo!, Twitter and Adobe, as well as a quickly \ngrowing number of start-ups to initiate research and development \nprojects and to deploy ConvNet-based image understanding products \nand services. \nConvNets are easily amenable to efficient hardware implemen­\ntations in chips or field-programmable gate arrays66,67. A number \nof companies such as NVIDIA, Mobileye, Intel, Qualcomm and \nSamsung are developing ConvNet chips to enable real-time vision \napplications in smartphones, cameras, robots and self-driving cars. \nDistributed representations and language processing \nDeep-learning theory shows that deep nets have two different expo­\nnential advantages over classic learning algorithms that do not use \ndistributed representations21. Both of these advantages arise from the \npower of composition and depend on the underlying data-generating \ndistribution having an appropriate componential structure40. First, \nlearning distributed representations enable generalization to new \ncombinations of the values of learned features beyond those seen \nduring training (for example, 2n combinations are possible with n \nbinary features)68,69. Second, composing layers of representation in \na deep net brings the potential for another exponential advantage70 \n(exponential in the depth). \nThe hidden layers of a multilayer neural network learn to repre­\nsent the network’s inputs in a way that makes it easy to predict the \ntarget outputs. This is nicely demonstrated by training a multilayer \nneural network to predict the next word in a sequence from a local \nFigure 3 | From image to text.  Captions generated by a recurrent neural \nnetwork (RNN) taking, as extra input, the representation extracted by a deep \nconvolution neural network (CNN) from a test image, with the RNN trained to \n‘translate’ high-level representations of images into captions (top). Reproduced \nwith permission from ref. 102. When the RNN is given the ability to focus its \nattention on a different location in the input image (middle and bottom; the \nlighter patches were given more attention) as it generates each word (bold), we \nfound86 that it exploits this to achieve better ‘translation’ of images into captions.\nVision\nDeep CNN\nLanguage\nGenerating RNN\nA group of people \nshopping at an outdoor \nmarket.\nThere are many \nvegetables at the \nfruit stand.\nA woman is throwing a frisbee in a park.\nA little girl sitting on a bed with a teddy bear.\nA group of people sitting on a boat in the water.\nA giraﬀe standing in a forest with\ntrees in the background.\nA dog is standing on a hardwood ﬂoor.\nA stop sign is on a road with a\nmountain in the background\n4 4 0  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "context of earlier words71. Each word in the context is presented to \nthe network as a one-of-N vector, that is, one component has a value \nof 1 and the rest are 0. In the first layer, each word creates a different \npattern of activations, or word vectors (Fig. 4). In a language model, \nthe other layers of the network learn to convert the input word vec­\ntors into an output word vector for the predicted next word, which \ncan be used to predict the probability for any word in the vocabulary \nto appear as the next word. The network learns word vectors that \ncontain many active components each of which can be interpreted \nas a separate feature of the word, as was first demonstrated27 in the \ncontext of learning distributed representations for symbols. These \nsemantic features were not explicitly present in the input. They were \ndiscovered by the learning procedure as a good way of factorizing \nthe structured relationships between the input and output symbols \ninto multiple ‘micro-rules’. Learning word vectors turned out to also \nwork very well when the word sequences come from a large corpus \nof real text and the individual micro-rules are unreliable71. When \ntrained to predict the next word in a news story, for example, the \nlearned word vectors for Tuesday and Wednesday are very similar, as \nare the word vectors for Sweden and Norway. Such representations \nare called distributed representations because their elements (the \nfeatures) are not mutually exclusive and their many configurations \ncorrespond to the variations seen in the observed data. These word \nvectors are composed of learned features that were not determined \nahead of time by experts, but automatically discovered by the neural \nnetwork. Vector representations of words learned from text are now \nvery widely used in natural language applications14,17,72–76. \nThe issue of representation lies at the heart of the debate between \nthe logic-inspired and the neural-network-inspired paradigms for \ncognition. In the logic-inspired paradigm, an instance of a symbol is \nsomething for which the only property is that it is either identical or \nnon-identical to other symbol instances. It has no internal structure \nthat is relevant to its use; and to reason with symbols, they must be \nbound to the variables in judiciously chosen rules of inference. By \ncontrast, neural networks just use big activity vectors, big weight \nmatrices and scalar non-linearities to perform the type of fast ‘intui­\ntive’ inference that underpins effortless commonsense reasoning. \nBefore the introduction of neural language models71, the standard \napproach to statistical modelling of language did not exploit distrib­\nuted representations: it was based on counting frequencies of occur­\nrences of short symbol sequences of length up to N (called N-grams). \nThe number of possible N-grams is on the order of VN, where V is \nthe vocabulary size, so taking into account a context of more than a \nhandful of words would require very large training corpora. N-grams \ntreat each word as an atomic unit, so they cannot generalize across \nsemantically related sequences of words, whereas neural language \nmodels can because they associate each word with a vector of real \nvalued features, and semantically related words end up close to each \nother in that vector space (Fig. 4). \nRecurrent neural networks \nWhen backpropagation was first introduced, its most exciting use was \nfor training recurrent neural networks (RNNs). For tasks that involve \nsequential inputs, such as speech and language, it is often better to \nuse RNNs (Fig. 5). RNNs process an input sequence one element at a \ntime, maintaining in their hidden units a ‘state vector’ that implicitly \ncontains information about the history of all the past elements of \nthe sequence. When we consider the outputs of the hidden units at \ndifferent discrete time steps as if they were the outputs of different \nneurons in a deep multilayer network (Fig. 5, right), it becomes clear \nhow we can apply backpropagation to train RNNs. \nRNNs are very powerful dynamic systems, but training them has \nproved to be problematic because the backpropagated gradients \neither grow or shrink at each time step, so over many time steps they \ntypically explode or vanish77,78. \nThanks to advances in their architecture79,80 and ways of training \nthem81,82, RNNs have been found to be very good at predicting the \nnext character in the text83 or the next word in a sequence75, but they \ncan also be used for more complex tasks. For example, after reading \nan English sentence one word at a time, an English ‘encoder’ network \ncan be trained so that the final state vector of its hidden units is a good \nrepresentation of the thought expressed by the sentence. This thought \nvector can then be used as the initial hidden state of (or as extra input \nto) a jointly trained French ‘decoder’ network, which outputs a prob­\nability distribution for the first word of the French translation. If a \nparticular first word is chosen from this distribution and provided \nas input to the decoder network it will then output a probability dis­\ntribution for the second word of the translation and so on until a \nfull stop is chosen17,72,76. Overall, this process generates sequences of \nFrench words according to a probability distribution that depends on \nthe English sentence. This rather naive way of performing machine \ntranslation has quickly become competitive with the state-of-the-art, \nand this raises serious doubts about whether understanding a sen­\ntence requires anything like the internal symbolic expressions that are \nmanipulated by using inference rules. It is more compatible with the \nview that everyday reasoning involves many simultaneous analogies \nFigure 4 | Visualizing the learned word vectors.  On the left is an illustration \nof word representations learned for modelling language, non-linearly projected \nto 2D for visualization using the t-SNE algorithm103. On the right is a 2D \nrepresentation of phrases learned by an English-to-French encoder–decoder \nrecurrent neural network75. One can observe that semantically similar words \nor sequences of words are mapped to nearby representations. The distributed \nrepresentations of words are obtained by using backpropagation to jointly learn \na representation for each word and a function that predicts a target quantity \nsuch as the next word in a sequence (for language modelling) or a whole \nsequence of translated words (for machine translation)18,75.\n−37\n−36\n−35\n−34\n−33\n−32\n−31\n−30\n−29\n9\n10\n10.5\n11\n11.5\n12\n12.5\n13\n13.5\n14\n community\n organizations  institutions\n society\n industry\n company\n organization\n school\n companies\n Community\n oﬃce\n Agency\n communities\n Association\n body\n schools\n agencies\n−5.5\n−5\n−4.5\n−4\n−3.5\n−3\n−2.5\n−2\n−4.2\n−4\n−3.8\n−3.6\n−3.4\n−3.2\n−3\n−2.8\n−2.6\n−2.4\n−2.2\nover the past few months\nthat a few days\nIn the last few days\nthe past few days\nIn a few months\nin the coming months\na few months ago\n&quot; the two groups\nof the two groups\nover the last few months\ndispute between the two\nthe last two decades\nthe next six months\ntwo months before being\nfor nearly two months\nover the last two decades\nwithin a few months\n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 4 1\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "that each contribute plausibility to a conclusion84,85. \nInstead of translating the meaning of a French sentence into an \nEnglish sentence, one can learn to ‘translate’ the meaning of an image \ninto an English sentence (Fig. 3). The encoder here is a deep Con­\nvNet that converts the pixels into an activity vector in its last hidden \nlayer. The decoder is an RNN similar to the ones used for machine \ntranslation and neural language modelling. There has been a surge of \ninterest in such systems recently (see examples mentioned in ref. 86). \nRNNs, once unfolded in time (Fig. 5), can be seen as very deep \nfeedforward networks in which all the layers share the same weights. \nAlthough their main purpose is to learn long-term dependencies, \ntheoretical and empirical evidence shows that it is difficult to learn \nto store information for very long78.  \nTo correct for that, one idea is to augment the network with an \nexplicit memory. The first proposal of this kind is the long short-term \nmemory (LSTM) networks that use special hidden units, the natural \nbehaviour of which is to remember inputs for a long time79. A special \nunit called the memory cell acts like an accumulator or a gated leaky \nneuron: it has a connection to itself at the next time step that has a \nweight of one, so it copies its own real-valued state and accumulates \nthe external signal, but this self-connection is multiplicatively gated \nby another unit that learns to decide when to clear the content of the \nmemory. \nLSTM networks have subsequently proved to be more effective \nthan conventional RNNs, especially when they have several layers for \neach time step87, enabling an entire speech recognition system that \ngoes all the way from acoustics to the sequence of characters in the \ntranscription. LSTM networks or related forms of gated units are also \ncurrently used for the encoder and decoder networks that perform \nso well at machine translation17,72,76. \nOver the past year, several authors have made different proposals to \naugment RNNs with a memory module. Proposals include the Neural \nTuring Machine in which the network is augmented by a ‘tape-like’ \nmemory that the RNN can choose to read from or write to88, and \nmemory networks, in which a regular network is augmented by a \nkind of associative memory89. Memory networks have yielded excel­\nlent performance on standard question-answering benchmarks. The \nmemory is used to remember the story about which the network is \nlater asked to answer questions. \nBeyond simple memorization, neural Turing machines and mem­\nory networks are being used for tasks that would normally require \nreasoning and symbol manipulation. Neural Turing machines can \nbe taught ‘algorithms’. Among other things, they can learn to output \na sorted list of symbols when their input consists of an unsorted \nsequence in which each symbol is accompanied by a real value that \nindicates its priority in the list88. Memory networks can be trained \nto keep track of the state of the world in a setting similar to a text \nadventure game and after reading a story, they can answer questions \nthat require complex inference90. In one test example, the network is \nshown a 15-sentence version of the The Lord of the Rings and correctly \nanswers questions such as “where is Frodo now?”89.  \nThe future of deep learning \nUnsupervised learning91–98 had a catalytic effect in reviving interest in \ndeep learning, but has since been overshadowed by the successes of \npurely supervised learning. Although we have not focused on it in this \nReview, we expect unsupervised learning to become far more important \nin the longer term. Human and animal learning is largely unsupervised: \nwe discover the structure of the world by observing it, not by being told \nthe name of every object. \nHuman vision is an active process that sequentially samples the optic \narray in an intelligent, task-speciﬁc way using a small, high-resolution \nfovea with a large, low-resolution surround. We expect much of the \nfuture progress in vision to come from systems that are trained end-to-\nend and combine ConvNets with RNNs that use reinforcement learning \nto decide where to look. Systems combining deep learning and rein­\nforcement learning are in their infancy, but they already outperform \npassive vision systems99 at classification tasks and produce impressive \nresults in learning to play many different video games100. \nNatural language understanding is another area in which deep learn­\ning is poised to make a large impact over the next few years. We expect \nsystems that use RNNs to understand sentences or whole documents \nwill become much better when they learn strategies for selectively \nattending to one part at a time76,86. \nUltimately, major progress in artificial intelligence will come about \nthrough systems that combine representation learning with complex \nreasoning. Although deep learning and simple reasoning have been \nused for speech and handwriting recognition for a long time, new \nparadigms are needed to replace rule-based manipulation of symbolic \nexpressions by operations on large vectors101. ■\nReceived 25 February; accepted 1 May 2015.\n1.\t\nKrizhevsky, A., Sutskever, I. & Hinton, G. ImageNet classification with deep \nconvolutional neural networks. In Proc. Advances in Neural Information \nProcessing Systems 25 1090–1098 (2012).\n\t\nThis report was a breakthrough that used convolutional nets to almost halve \nthe error rate for object recognition, and precipitated the rapid adoption of \ndeep learning by the computer vision community.\n2.\t\nFarabet, C., Couprie, C., Najman, L. & LeCun, Y. Learning hierarchical features for \nscene labeling. IEEE Trans. Pattern Anal. Mach. Intell. 35, 1915–1929 (2013). \n3.\t\nTompson, J., Jain, A., LeCun, Y. & Bregler, C. Joint training of a convolutional \nnetwork and a graphical model for human pose estimation. In Proc. Advances in \nNeural Information Processing Systems 27 1799–1807 (2014). \n4.\t\nSzegedy, C. et al. Going deeper with convolutions. Preprint at http://arxiv.org/\nabs/1409.4842 (2014). \n5.\t\nMikolov, T., Deoras, A., Povey, D., Burget, L. & Cernocky, J. Strategies for training \nlarge scale neural network language models. In Proc. Automatic Speech \nRecognition and Understanding 196–201 (2011). \n6.\t\nHinton, G. et al. Deep neural networks for acoustic modeling in speech \nrecognition. IEEE Signal Processing Magazine 29, 82–97 (2012).\n\t\nThis joint paper from the major speech recognition laboratories, summarizing \nthe breakthrough achieved with deep learning on the task of phonetic \nclassification for automatic speech recognition, was the first major industrial \napplication of deep learning.\n7.\t\nSainath, T., Mohamed, A.-R., Kingsbury, B. & Ramabhadran, B. Deep \nconvolutional neural networks for LVCSR. In Proc. Acoustics, Speech and Signal \nProcessing 8614–8618 (2013). \n8.\t\nMa, J., Sheridan, R. P., Liaw, A., Dahl, G. E. & Svetnik, V. Deep neural nets as a \nmethod for quantitative structure-activity relationships. J. Chem. Inf. Model. 55, \n263–274 (2015). \n9.\t\nCiodaro, T., Deva, D., de Seixas, J. & Damazio, D. Online particle detection with \nneural networks based on topological calorimetry information. J. Phys. Conf. \nSeries 368, 012030 (2012). \n10.\t Kaggle. Higgs boson machine learning challenge. Kaggle https://www.kaggle.\ncom/c/higgs-boson (2014). \n11.\t Helmstaedter, M. et al. Connectomic reconstruction of the inner plexiform layer \nin the mouse retina. Nature 500, 168–174 (2013). \nxt\nxt−1\nxt+1\nx\nUnfold\nV\nW\nW\nW\nW\nW\nV\nV\nV\nU\nU\nU\nU\ns\no\nst−1\not−1\not\nst\nst+1\not+1\nFigure 5 | A recurrent neural network and the unfolding in time of the \ncomputation involved in its forward computation.  The artificial neurons \n(for example, hidden units grouped under node s with values st at time t) get \ninputs from other neurons at previous time steps (this is represented with the \nblack square, representing a delay of one time step, on the left). In this way, a \nrecurrent neural network can map an input sequence with elements xt into an \noutput sequence with elements ot, with each ot depending on all the previous \nxtʹ (for tʹ ≤ t). The same parameters (matrices U,V,W ) are used at each time \nstep. Many other architectures are possible, including a variant in which the \nnetwork can generate a sequence of outputs (for example, words), each of \nwhich is used as inputs for the next time step. The backpropagation algorithm \n(Fig. 1) can be directly applied to the computational graph of the unfolded \nnetwork on the right, to compute the derivative of a total error (for example, \nthe log-probability of generating the right sequence of outputs) with respect to \nall the states st and all the parameters.\n4 4 2  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "12.\t Leung, M. K., Xiong, H. Y., Lee, L. J. & Frey, B. J. Deep learning of the tissue-\nregulated splicing code. Bioinformatics 30, i121–i129 (2014). \n13.\t Xiong, H. Y. et al. The human splicing code reveals new insights into the genetic \ndeterminants of disease. Science 347, 6218 (2015). \n14.\t Collobert, R., et al. Natural language processing (almost) from scratch. J. Mach. \nLearn. Res. 12, 2493–2537 (2011). \n15.\t Bordes, A., Chopra, S. & Weston, J. Question answering with subgraph \nembeddings. In Proc. Empirical Methods in Natural Language Processing http://\narxiv.org/abs/1406.3676v3 (2014). \n16.\t Jean, S., Cho, K., Memisevic, R. & Bengio, Y. On using very large target \nvocabulary for neural machine translation. In Proc. ACL-IJCNLP http://arxiv.org/\nabs/1412.2007 (2015).\n17.\t Sutskever, I. Vinyals, O. & Le. Q. V. Sequence to sequence learning with neural \nnetworks. In Proc. Advances in Neural Information Processing Systems 27 \n3104–3112 (2014). \n\t\nThis paper showed state-of-the-art machine translation results with the \narchitecture introduced in ref. 72, with a recurrent network trained to read a \nsentence in one language, produce a semantic representation of its meaning, \nand generate a translation in another language.\n18.\t Bottou, L. & Bousquet, O. The tradeoffs of large scale learning. In Proc. Advances \nin Neural Information Processing Systems 20 161–168 (2007). \n19.\t Duda, R. O. & Hart, P. E. Pattern Classiﬁcation and Scene Analysis (Wiley, 1973). \n20.\t Schölkopf, B. & Smola, A. Learning with Kernels (MIT Press, 2002). \n21.\t Bengio, Y., Delalleau, O. & Le Roux, N. The curse of highly variable functions \nfor local kernel machines. In Proc. Advances in Neural Information Processing \nSystems 18 107–114 (2005). \n22.\t Selfridge, O. G. Pandemonium: a paradigm for learning in mechanisation of \nthought processes. In Proc. Symposium on Mechanisation of Thought Processes \n513–526 (1958). \n23.\t Rosenblatt, F. The Perceptron — A Perceiving and Recognizing Automaton. Tech. \nRep. 85-460-1 (Cornell Aeronautical Laboratory, 1957). \n24.\t Werbos, P. Beyond Regression: New Tools for Prediction and Analysis in the \nBehavioral Sciences. PhD thesis, Harvard Univ. (1974). \n25.\t Parker, D. B. Learning Logic Report TR–47 (MIT Press, 1985). \n26.\t LeCun, Y. Une procédure d’apprentissage pour Réseau à seuil assymétrique \nin Cognitiva 85: a la Frontière de l’Intelligence Artiﬁcielle, des Sciences de la \nConnaissance et des Neurosciences [in French] 599–604 (1985). \n27.\t Rumelhart, D. E., Hinton, G. E. & Williams, R. J. Learning representations by \nback-propagating errors. Nature 323, 533–536 (1986). \n28.\t Glorot, X., Bordes, A. & Bengio. Y. Deep sparse rectiﬁer neural networks. In Proc. \n14th International Conference on Artificial Intelligence and Statistics 315–323 \n(2011). \n\t\nThis paper showed that supervised training of very deep neural networks is \nmuch faster if the hidden layers are composed of ReLU.\n29.\t Dauphin, Y. et al. Identifying and attacking the saddle point problem in high-\ndimensional non-convex optimization. In Proc. Advances in Neural Information \nProcessing Systems 27 2933–2941 (2014). \n30.\t Choromanska, A., Henaff, M., Mathieu, M., Arous, G. B. & LeCun, Y. The loss \nsurface of multilayer networks. In Proc. Conference on AI and Statistics http://\narxiv.org/abs/1412.0233 (2014). \n31.\t Hinton, G. E. What kind of graphical model is the brain? In Proc. 19th \nInternational Joint Conference on Artificial intelligence 1765–1775 (2005). \n32.\t Hinton, G. E., Osindero, S. & Teh, Y.-W. A fast learning algorithm for deep belief \nnets. Neural Comp. 18, 1527–1554 (2006).\n\t\nThis paper introduced a novel and effective way of training very deep neural \nnetworks by pre-training one hidden layer at a time using the unsupervised \nlearning procedure for restricted Boltzmann machines. \n33.\t Bengio, Y., Lamblin, P., Popovici, D. & Larochelle, H. Greedy layer-wise training \nof deep networks. In Proc. Advances in Neural Information Processing Systems 19 \n153–160 (2006). \n\t\nThis report demonstrated that the unsupervised pre-training method \nintroduced in ref. 32 significantly improves performance on test data and \ngeneralizes the method to other unsupervised representation-learning \ntechniques, such as auto-encoders.\n34.\t Ranzato, M., Poultney, C., Chopra, S. & LeCun, Y. Efﬁcient learning of sparse \nrepresentations with an energy-based model. In Proc. Advances in Neural \nInformation Processing Systems 19 1137–1144 (2006). \n35.\t Hinton, G. E. & Salakhutdinov, R. Reducing the dimensionality of data with \nneural networks. Science 313, 504–507 (2006). \n36.\t Sermanet, P., Kavukcuoglu, K., Chintala, S. & LeCun, Y. Pedestrian detection with \nunsupervised multi-stage feature learning. In Proc. International Conference \non Computer Vision and Pattern Recognition http://arxiv.org/abs/1212.0142 \n(2013). \n37.\t Raina, R., Madhavan, A. & Ng, A. Y. Large-scale deep unsupervised learning \nusing graphics processors. In Proc. 26th Annual International Conference on \nMachine Learning 873–880 (2009). \n38.\t Mohamed, A.-R., Dahl, G. E. & Hinton, G. Acoustic modeling using deep belief \nnetworks. IEEE Trans. Audio Speech Lang. Process. 20, 14–22 (2012). \n39.\t Dahl, G. E., Yu, D., Deng, L. & Acero, A. Context-dependent pre-trained deep \nneural networks for large vocabulary speech recognition. IEEE Trans. Audio \nSpeech Lang. Process. 20, 33–42 (2012). \n40.\t Bengio, Y., Courville, A. & Vincent, P. Representation learning: a review and new \nperspectives. IEEE Trans. Pattern Anal. Machine Intell. 35, 1798–1828 (2013). \n41.\t LeCun, Y. et al. Handwritten digit recognition with a back-propagation network. \nIn Proc. Advances in Neural Information Processing Systems 396–404 (1990). \n\t\nThis is the first paper on convolutional networks trained by backpropagation \nfor the task of classifying low-resolution images of handwritten digits.\n42.\t LeCun, Y., Bottou, L., Bengio, Y. & Haffner, P. Gradient-based learning applied to \ndocument recognition. Proc. IEEE 86, 2278–2324 (1998). \n\t\nThis overview paper on the principles of end-to-end training of modular \nsystems such as deep neural networks using gradient-based optimization \nshowed how neural networks (and in particular convolutional nets) can be \ncombined with search or inference mechanisms to model complex outputs \nthat are interdependent, such as sequences of characters associated with the \ncontent of a document.\n43.\t Hubel, D. H. & Wiesel, T. N. Receptive ﬁelds, binocular interaction, and functional \narchitecture in the cat’s visual cortex. J. Physiol. 160, 106–154 (1962). \n44.\t Felleman, D. J. & Essen, D. C. V. Distributed hierarchical processing in the \nprimate cerebral cortex. Cereb. Cortex 1, 1–47 (1991). \n45.\t Cadieu, C. F. et al. Deep neural networks rival the representation of primate \nit cortex for core visual object recognition. PLoS Comp. Biol. 10, e1003963 \n(2014). \n46.\t Fukushima, K. & Miyake, S. Neocognitron: a new algorithm for pattern \nrecognition tolerant of deformations and shifts in position. Pattern Recognition \n15, 455–469 (1982). \n47.\t Waibel, A., Hanazawa, T., Hinton, G. E., Shikano, K. & Lang, K. Phoneme \nrecognition using time-delay neural networks. IEEE Trans. Acoustics Speech \nSignal Process. 37, 328–339 (1989). \n48.\t Bottou, L., Fogelman-Soulié, F., Blanchet, P. & Lienard, J. Experiments with time \ndelay networks and dynamic time warping for speaker independent isolated \ndigit recognition. In Proc. EuroSpeech 89 537–540 (1989). \n49.\t Simard, D., Steinkraus, P. Y. & Platt, J. C. Best practices for convolutional neural \nnetworks. In Proc. Document Analysis and Recognition 958–963 (2003). \n50.\t Vaillant, R., Monrocq, C. & LeCun, Y. Original approach for the localisation of \nobjects in images. In Proc. Vision, Image, and Signal Processing 141, 245–250 \n(1994). \n51.\t Nowlan, S. & Platt, J. in Neural Information Processing Systems 901–908 (1995). \n52.\t Lawrence, S., Giles, C. L., Tsoi, A. C. & Back, A. D. Face recognition: a \nconvolutional neural-network approach. IEEE Trans. Neural Networks 8, 98–113 \n(1997). \n53.\t Ciresan, D., Meier, U. Masci, J. & Schmidhuber, J. Multi-column deep neural \nnetwork for trafﬁc sign classiﬁcation. Neural Networks 32, 333–338 (2012). \n54.\t Ning, F. et al. Toward automatic phenotyping of developing embryos from \nvideos. IEEE Trans. Image Process. 14, 1360–1371 (2005). \n55.\t Turaga, S. C. et al. Convolutional networks can learn to generate afﬁnity graphs \nfor image segmentation. Neural Comput. 22, 511–538 (2010). \n56.\t Garcia, C. & Delakis, M. Convolutional face ﬁnder: a neural architecture for \nfast and robust face detection. IEEE Trans. Pattern Anal. Machine Intell. 26, \n1408–1423 (2004). \n57.\t Osadchy, M., LeCun, Y. & Miller, M. Synergistic face detection and pose \nestimation with energy-based models. J. Mach. Learn. Res. 8, 1197–1215 \n(2007). \n58.\t Tompson, J., Goroshin, R. R., Jain, A., LeCun, Y. Y. & Bregler, C. C. Efﬁcient object \nlocalization using convolutional networks. In Proc. Conference on Computer \nVision and Pattern Recognition http://arxiv.org/abs/1411.4280 (2014). \n59.\t Taigman, Y., Yang, M., Ranzato, M. & Wolf, L. Deepface: closing the gap to \nhuman-level performance in face veriﬁcation. In Proc. Conference on Computer \nVision and Pattern Recognition 1701–1708 (2014). \n60.\t Hadsell, R. et al. Learning long-range vision for autonomous off-road driving. \nJ. Field Robot. 26, 120–144 (2009). \n61.\t Farabet, C., Couprie, C., Najman, L. & LeCun, Y. Scene parsing with multiscale \nfeature learning, purity trees, and optimal covers. In Proc. International \nConference on Machine Learning http://arxiv.org/abs/1202.2160 (2012). \n62.\t Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I. & Salakhutdinov, R. \nDropout: a simple way to prevent neural networks from overﬁtting. J. Machine \nLearning Res. 15, 1929–1958 (2014). \n63.\t Sermanet, P. et al. Overfeat: integrated recognition, localization and detection \nusing convolutional networks. In Proc. International Conference on Learning \nRepresentations http://arxiv.org/abs/1312.6229 (2014). \n64.\t Girshick, R., Donahue, J., Darrell, T. & Malik, J. Rich feature hierarchies for \naccurate object detection and semantic segmentation. In Proc. Conference on \nComputer Vision and Pattern Recognition 580–587 (2014). \n65.\t Simonyan, K. & Zisserman, A. Very deep convolutional networks for large-scale \nimage recognition. In Proc. International Conference on Learning Representations \nhttp://arxiv.org/abs/1409.1556 (2014). \n66.\t Boser, B., Sackinger, E., Bromley, J., LeCun, Y. & Jackel, L. An analog neural \nnetwork processor with programmable topology. J. Solid State Circuits 26, \n2017–2025 (1991). \n67.\t Farabet, C. et al. Large-scale FPGA-based convolutional networks. In Scaling \nup Machine Learning: Parallel and Distributed Approaches (eds Bekkerman, R., \nBilenko, M. & Langford, J.) 399–419 (Cambridge Univ. Press, 2011). \n68.\t Bengio, Y. Learning Deep Architectures for AI (Now, 2009). \n69.\t Montufar, G. & Morton, J. When does a mixture of products contain a product of \nmixtures? J. Discrete Math. 29, 321–347 (2014). \n70.\t Montufar, G. F., Pascanu, R., Cho, K. & Bengio, Y. On the number of linear regions \nof deep neural networks. In Proc. Advances in Neural Information Processing \nSystems 27 2924–2932 (2014). \n71.\t Bengio, Y., Ducharme, R. & Vincent, P. A neural probabilistic language model. In \nProc. Advances in Neural Information Processing Systems 13 932–938 (2001). \n\t\nThis paper introduced neural language models, which learn to convert a word \nsymbol into a word vector or word embedding composed of learned semantic \nfeatures in order to predict the next word in a sequence.\n72.\t Cho, K. et al. Learning phrase representations using RNN encoder-decoder \n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 4 3\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n",
    "for statistical machine translation. In Proc. Conference on Empirical Methods in \nNatural Language Processing 1724–1734 (2014).  \n73.\t Schwenk, H. Continuous space language models. Computer Speech Lang. 21, \n492–518 (2007). \n74.\t Socher, R., Lin, C. C-Y., Manning, C. & Ng, A. Y. Parsing natural scenes and \nnatural language with recursive neural networks. In Proc. International \nConference on Machine Learning 129–136 (2011). \n75.\t Mikolov, T., Sutskever, I., Chen, K., Corrado, G. & Dean, J. Distributed \nrepresentations of words and phrases and their compositionality. In Proc. \nAdvances in Neural Information Processing Systems 26 3111–3119 (2013). \n76.\t Bahdanau, D., Cho, K. & Bengio, Y. Neural machine translation by jointly \nlearning to align and translate. In Proc. International Conference on Learning \nRepresentations http://arxiv.org/abs/1409.0473 (2015).\n77.\t Hochreiter, S. Untersuchungen zu dynamischen neuronalen Netzen [in \nGerman] Diploma thesis, T.U. Münich (1991). \n78.\t Bengio, Y., Simard, P. & Frasconi, P. Learning long-term dependencies with \ngradient descent is difﬁcult. IEEE Trans. Neural Networks 5, 157–166 (1994). \n79.\t Hochreiter, S. & Schmidhuber, J. Long short-term memory. Neural Comput. 9, \n1735–1780 (1997). \n\t\nThis paper introduced LSTM recurrent networks, which have become a crucial \ningredient in recent advances with recurrent networks because they are good \nat learning long-range dependencies. \n80.\t ElHihi, S. & Bengio, Y. Hierarchical recurrent neural networks for long-term \ndependencies. In Proc. Advances in Neural Information Processing Systems 8 \nhttp://papers.nips.cc/paper/1102-hierarchical-recurrent-neural-networks-for-\nlong-term-dependencies (1995). \n81.\t Sutskever, I. Training Recurrent Neural Networks. PhD thesis, Univ. Toronto \n(2012). \n82.\t Pascanu, R., Mikolov, T. & Bengio, Y. On the difﬁculty of training recurrent neural \nnetworks. In Proc. 30th International Conference on Machine Learning 1310–\n1318 (2013). \n83.\t Sutskever, I., Martens, J. & Hinton, G. E. Generating text with recurrent neural \nnetworks. In Proc. 28th International Conference on Machine Learning 1017–\n1024 (2011). \n84.\t Lakoff, G. & Johnson, M. Metaphors We Live By (Univ. Chicago Press, 2008). \n85.\t Rogers, T. T. & McClelland, J. L. Semantic Cognition: A Parallel Distributed \nProcessing Approach (MIT Press, 2004). \n86.\t Xu, K. et al. Show, attend and tell: Neural image caption generation with visual \nattention. In Proc. International Conference on Learning Representations http://\narxiv.org/abs/1502.03044 (2015). \n87.\t Graves, A., Mohamed, A.-R. & Hinton, G. Speech recognition with deep recurrent \nneural networks. In Proc. International Conference on Acoustics, Speech and \nSignal Processing 6645–6649 (2013). \n88.\t Graves, A., Wayne, G. & Danihelka, I. Neural Turing machines. http://arxiv.org/\nabs/1410.5401 (2014). \n89.\t Weston, J. Chopra, S. & Bordes, A. Memory networks. http://arxiv.org/\nabs/1410.3916 (2014). \n90.\t Weston, J., Bordes, A., Chopra, S. & Mikolov, T. Towards AI-complete question \nanswering: a set of prerequisite toy tasks. http://arxiv.org/abs/1502.05698 \n(2015). \n91.\t Hinton, G. E., Dayan, P., Frey, B. J. & Neal, R. M. The wake-sleep algorithm for \nunsupervised neural networks. Science 268, 1558–1161 (1995). \n92.\t Salakhutdinov, R. & Hinton, G. Deep Boltzmann machines. In Proc. International \nConference on Artificial Intelligence and Statistics 448–455 (2009). \n93.\t Vincent, P., Larochelle, H., Bengio, Y. & Manzagol, P.-A. Extracting and composing \nrobust features with denoising autoencoders. In Proc. 25th International \nConference on Machine Learning 1096–1103 (2008). \n94.\t Kavukcuoglu, K. et al. Learning convolutional feature hierarchies for visual \nrecognition. In Proc. Advances in Neural Information Processing Systems 23 \n1090–1098 (2010). \n95.\t Gregor, K. & LeCun, Y. Learning fast approximations of sparse coding. In Proc. \nInternational Conference on Machine Learning 399–406 (2010). \n96.\t Ranzato, M., Mnih, V., Susskind, J. M. & Hinton, G. E. Modeling natural images \nusing gated MRFs. IEEE Trans. Pattern Anal. Machine Intell. 35, 2206–2222 \n(2013). \n97.\t Bengio, Y., Thibodeau-Laufer, E., Alain, G. & Yosinski, J. Deep generative \nstochastic networks trainable by backprop. In Proc. 31st International \nConference on Machine Learning 226–234 (2014). \n98.\t Kingma, D., Rezende, D., Mohamed, S. & Welling, M. Semi-supervised learning \nwith deep generative models. In Proc. Advances in Neural Information Processing \nSystems 27 3581–3589 (2014). \n99.\t Ba, J., Mnih, V. & Kavukcuoglu, K. Multiple object recognition with visual \nattention. In Proc. International Conference on Learning Representations http://\narxiv.org/abs/1412.7755 (2014). \n100.\tMnih, V. et al. Human-level control through deep reinforcement learning. Nature  \n518, 529–533 (2015).\n101.\tBottou, L. From machine learning to machine reasoning. Mach. Learn. 94, \n133–149 (2014). \n102.\tVinyals, O., Toshev, A., Bengio, S. & Erhan, D. Show and tell: a neural image \ncaption generator. In Proc. International Conference on Machine Learning http://\narxiv.org/abs/1502.03044 (2014).\n103.\tvan der Maaten, L. & Hinton, G. E. Visualizing data using t-SNE. J. Mach. Learn.\nResearch 9, 2579–2605 (2008).\nAcknowledgements The authors would like to thank the Natural Sciences and \nEngineering Research Council of Canada, the Canadian Institute For Advanced \nResearch (CIFAR), the National Science Foundation and Office of Naval Research \nfor support. Y.L. and Y.B. are CIFAR fellows.\nAuthor Information Reprints and permissions information is available at \nwww.nature.com/reprints. The authors declare no competing financial \ninterests. Readers are welcome to comment on the online version of this \npaper at go.nature.com/7cjbaa. Correspondence should be addressed to Y.L. \n(yann@cs.nyu.edu).\n4 4 4  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n"
  ],
  "full_text": "1Facebook AI Research, 770 Broadway, New York, New York 10003 USA. 2New York University, 715 Broadway, New York, New York 10003, USA. 3Department of Computer Science and Operations \nResearch Université de Montréal, Pavillon André-Aisenstadt, PO Box 6128  Centre-Ville STN Montréal, Quebec H3C 3J7, Canada. 4Google, 1600 Amphitheatre Parkway, Mountain View, California \n94043, USA. 5Department of Computer Science, University of Toronto, 6 King’s College Road, Toronto, Ontario M5S 3G4, Canada.\nM\nachine-learning technology powers many aspects of modern \nsociety: from web searches to content filtering on social net­\nworks to recommendations on e-commerce websites, and \nit is increasingly present in consumer products such as cameras and \nsmartphones. Machine-learning systems are used to identify objects \nin images, transcribe speech into text, match news items, posts or \nproducts with users’ interests, and select relevant results of search. \nIncreasingly, these applications make use of a class of techniques called \ndeep learning. \nConventional machine-learning techniques were limited in their \nability to process natural data in their raw form. For decades, con­\nstructing a pattern-recognition or machine-learning system required \ncareful engineering and considerable domain expertise to design a fea­\nture extractor that transformed the raw data (such as the pixel values \nof an image) into a suitable internal representation or feature vector \nfrom which the learning subsystem, often a classifier, could detect or \nclassify patterns in the input. \nRepresentation learning is a set of methods that allows a machine to \nbe fed with raw data and to automatically discover the representations \nneeded for detection or classification. Deep-learning methods are \nrepresentation-learning methods with multiple levels of representa­\ntion, obtained by composing simple but non-linear modules that each \ntransform the representation at one level (starting with the raw input) \ninto a representation at a higher, slightly more abstract level. With the \ncomposition of enough such transformations, very complex functions \ncan be learned. For classification tasks, higher layers of representation \namplify aspects of the input that are important for discrimination and \nsuppress irrelevant variations. An image, for example, comes in the \nform of an array of pixel values, and the learned features in the first \nlayer of representation typically represent the presence or absence of \nedges at particular orientations and locations in the image. The second \nlayer typically detects motifs by spotting particular arrangements of \nedges, regardless of small variations in the edge positions. The third \nlayer may assemble motifs into larger combinations that correspond \nto parts of familiar objects, and subsequent layers would detect objects \nas combinations of these parts. The key aspect of deep learning is that \nthese layers of features are not designed by human engineers: they \nare learned from data using a general-purpose learning procedure. \nDeep learning is making major advances in solving problems that \nhave resisted the best attempts of the artificial intelligence commu­\nnity for many years. It has turned out to be very good at discovering \nintricate structures in high-dimensional data and is therefore applica­\nble to many domains of science, business and government. In addition \nto beating records in image recognition1–4 and speech recognition5–7, it \nhas beaten other machine-learning techniques at predicting the activ­\nity of potential drug molecules8, analysing particle accelerator data9,10, \nreconstructing brain circuits11, and predicting the effects of mutations \nin non-coding DNA on gene expression and disease12,13. Perhaps more \nsurprisingly, deep learning has produced extremely promising results \nfor various tasks in natural language understanding14, particularly \ntopic classification, sentiment analysis, question answering15 and lan­\nguage translation16,17. \nWe think that deep learning will have many more successes in the \nnear future because it requires very little engineering by hand, so it \ncan easily take advantage of increases in the amount of available com­\nputation and data. New learning algorithms and architectures that are \ncurrently being developed for deep neural networks will only acceler­\nate this progress. \nSupervised learning \nThe most common form of machine learning, deep or not, is super­\nvised learning. Imagine that we want to build a system that can classify \nimages as containing, say, a house, a car, a person or a pet. We first \ncollect a large data set of images of houses, cars, people and pets, each \nlabelled with its category. During training, the machine is shown an \nimage and produces an output in the form of a vector of scores, one \nfor each category. We want the desired category to have the highest \nscore of all categories, but this is unlikely to happen before training. \nWe compute an objective function that measures the error (or dis­\ntance) between the output scores and the desired pattern of scores. The \nmachine then modifies its internal adjustable parameters to reduce \nthis error. These adjustable parameters, often called weights, are real \nnumbers that can be seen as ‘knobs’ that define the input–output func­\ntion of the machine. In a typical deep-learning system, there may be \nhundreds of millions of these adjustable weights, and hundreds of \nmillions of labelled examples with which to train the machine. \nTo properly adjust the weight vector, the learning algorithm com­\nputes a gradient vector that, for each weight, indicates by what amount \nthe error would increase or decrease if the weight were increased by a \ntiny amount. The weight vector is then adjusted in the opposite direc­\ntion to the gradient vector. \nThe objective function, averaged over all the training examples, can \nDeep learning allows computational models that are composed of multiple processing layers to learn representations of \ndata with multiple levels of abstraction. These methods have dramatically improved the state-of-the-art in speech rec­\nognition, visual object recognition, object detection and many other domains such as drug discovery and genomics. Deep \nlearning discovers intricate structure in large data sets by using the backpropagation algorithm to indicate how a machine \nshould change its internal parameters that are used to compute the representation in each layer from the representation in \nthe previous layer. Deep convolutional nets have brought about breakthroughs in processing images, video, speech and \naudio, whereas recurrent nets have shone light on sequential data such as text and speech. \nDeep learning\nYann LeCun1,2, Yoshua Bengio3 & Geoffrey Hinton4,5\n4 3 6  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\ndoi:10.1038/nature14539\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nbe seen as a kind of hilly landscape in the high-dimensional space of \nweight values. The negative gradient vector indicates the direction \nof steepest descent in this landscape, taking it closer to a minimum, \nwhere the output error is low on average. \nIn practice, most practitioners use a procedure called stochastic \ngradient descent (SGD). This consists of showing the input vector \nfor a few examples, computing the outputs and the errors, computing \nthe average gradient for those examples, and adjusting the weights \naccordingly. The process is repeated for many small sets of examples \nfrom the training set until the average of the objective function stops \ndecreasing. It is called stochastic because each small set of examples \ngives a noisy estimate of the average gradient over all examples. This \nsimple procedure usually finds a good set of weights surprisingly \nquickly when compared with far more elaborate optimization tech­\nniques18. After training, the performance of the system is measured \non a different set of examples called a test set. This serves to test the \ngeneralization ability of the machine — its ability to produce sensible \nanswers on new inputs that it has never seen during training. \nMany of the current practical applications of machine learning use \nlinear classifiers on top of hand-engineered features. A two-class linear \nclassifier computes a weighted sum of the feature vector components. \nIf the weighted sum is above a threshold, the input is classified as \nbelonging to a particular category. \nSince the 1960s we have known that linear classifiers can only carve \ntheir input space into very simple regions, namely half-spaces sepa­\nrated by a hyperplane19. But problems such as image and speech recog­\nnition require the input–output function to be insensitive to irrelevant \nvariations of the input, such as variations in position, orientation or \nillumination of an object, or variations in the pitch or accent of speech, \nwhile being very sensitive to particular minute variations (for example, \nthe difference between a white wolf and a breed of wolf-like white \ndog called a Samoyed). At the pixel level, images of two Samoyeds in \ndifferent poses and in different environments may be very different \nfrom each other, whereas two images of a Samoyed and a wolf in the \nsame position and on similar backgrounds may be very similar to each \nother. A linear classifier, or any other ‘shallow’ classifier operating on \nFigure 1 | Multilayer neural networks and backpropagation.  a, A multi-\nlayer neural network (shown by the connected dots) can distort the input \nspace to make the classes of data (examples of which are on the red and \nblue lines) linearly separable. Note how a regular grid (shown on the left) \nin input space is also transformed (shown in the middle panel) by hidden \nunits. This is an illustrative example with only two input units, two hidden \nunits and one output unit, but the networks used for object recognition \nor natural language processing contain tens or hundreds of thousands of \nunits. Reproduced with permission from C. Olah (http://colah.github.io/). \nb, The chain rule of derivatives tells us how two small effects (that of a small \nchange of x on y, and that of y on z) are composed. A small change Δx in \nx gets transformed first into a small change Δy in y by getting multiplied \nby ∂y/∂x (that is, the definition of partial derivative). Similarly, the change \nΔy creates a change Δz in z. Substituting one equation into the other \ngives the chain rule of derivatives — how Δx gets turned into Δz through \nmultiplication by the product of ∂y/∂x and ∂z/∂x. It also works when x, \ny and z are vectors (and the derivatives are Jacobian matrices). c, The \nequations used for computing the forward pass in a neural net with two \nhidden layers and one output layer, each constituting a module through \nwhich one can backpropagate gradients. At each layer, we first compute \nthe total input z to each unit, which is a weighted sum of the outputs of \nthe units in the layer below. Then a non-linear function f(.) is applied to \nz to get the output of the unit. For simplicity, we have omitted bias terms. \nThe non-linear functions used in neural networks include the rectified \nlinear unit (ReLU) f(z) = max(0,z), commonly used in recent years, as \nwell as the more conventional sigmoids, such as the hyberbolic tangent, \nf(z) = (exp(z) − exp(−z))/(exp(z) + exp(−z)) and logistic function logistic, \nf(z) = 1/(1 + exp(−z)). d, The equations used for computing the backward \npass. At each hidden layer we compute the error derivative with respect to \nthe output of each unit, which is a weighted sum of the error derivatives \nwith respect to the total inputs to the units in the layer above. We then \nconvert the error derivative with respect to the output into the error \nderivative with respect to the input by multiplying it by the gradient of f(z). \nAt the output layer, the error derivative with respect to the output of a unit \nis computed by differentiating the cost function. This gives yl − tl if the cost \nfunction for unit l is 0.5(yl − tl)2, where tl is the target value. Once the ∂E/∂zk \nis known, the error-derivative for the weight wjk on the connection from \nunit j in the layer below is just yj ∂E/∂zk.\nInput\n(2)\nOutput\n(1 sigmoid)\nHidden\n(2 sigmoid)\na\nb\nd\nc\ny\ny\nx\ny\nx\n\n\n=\ny\nz\n\n\nx\ny\n\n\nz\ny\nz\nz\ny\n\n\n=\nΔ\nΔ\nΔ\nΔ\nΔ\nΔ\nz\ny\nz\nx\ny\nx\n\n\n\n\n=\nx\nz\ny\nz\nx\nx\ny\n\n\n\n\n\n\n=\nCompare outputs with correct \nanswer to get error derivatives\nj\nk\nE\nyl\n=yl\ntl\nE\nzl\n= E\nyl\nyl\nzl\nl\nE\nyj\n=\nwjk\nE\nzk\nE\nzj\n= E\nyj\nyj\nzj\nE\nyk\n=\nwkl\nE\nzl\nE\nzk\n= E\nyk\nyk\nzk\nwkl\nwjk\nwij\ni\nj\nk\nyl = f (zl)\nzl =\nwkl yk\nl\nyj = f (zj)\nzj =\nwij xi\nyk = f (zk)\nzk =\nwjk yj\nOutput units \nInput units \nHidden units H2 \nHidden units H1 \nwkl\nwjk\nwij\nk  H2\nk  H2\nI  out\nj  H1\ni  Input\ni\n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 3 7\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nraw pixels could not possibly distinguish the latter two, while putting \nthe former two in the same category. This is why shallow classifiers \nrequire a good feature extractor that solves the selectivity–invariance \ndilemma — one that produces representations that are selective to \nthe aspects of the image that are important for discrimination, but \nthat are invariant to irrelevant aspects such as the pose of the animal. \nTo make classifiers more powerful, one can use generic non-linear \nfeatures, as with kernel methods20, but generic features such as those \narising with the Gaussian kernel do not allow the learner to general­\nize well far from the training examples21. The conventional option is \nto hand design good feature extractors, which requires a consider­\nable amount of engineering skill and domain expertise. But this can \nall be avoided if good features can be learned automatically using a \ngeneral-purpose learning procedure. This is the key advantage of \ndeep learning. \nA deep-learning architecture is a multilayer stack of simple mod­\nules, all (or most) of which are subject to learning, and many of which \ncompute non-linear input–output mappings. Each module in the \nstack transforms its input to increase both the selectivity and the \ninvariance of the representation. With multiple non-linear layers, say \na depth of 5 to 20, a system can implement extremely intricate func­\ntions of its inputs that are simultaneously sensitive to minute details \n— distinguishing Samoyeds from white wolves — and insensitive to \nlarge irrelevant variations such as the background, pose, lighting and \nsurrounding objects. \nBackpropagation to train multilayer architectures \nFrom the earliest days of pattern recognition22,23, the aim of research­\ners has been to replace hand-engineered features with trainable \nmultilayer networks, but despite its simplicity, the solution was not \nwidely understood until the mid 1980s. As it turns out, multilayer \narchitectures can be trained by simple stochastic gradient descent. \nAs long as the modules are relatively smooth functions of their inputs \nand of their internal weights, one can compute gradients using the \nbackpropagation procedure. The idea that this could be done, and \nthat it worked, was discovered independently by several different \ngroups during the 1970s and 1980s24–27.  \nThe backpropagation procedure to compute the gradient of an \nobjective function with respect to the weights of a multilayer stack \nof modules is nothing more than a practical application of the chain \nrule for derivatives. The key insight is that the derivative (or gradi­\nent) of the objective with respect to the input of a module can be \ncomputed by working backwards from the gradient with respect to \nthe output of that module (or the input of the subsequent module) \n(Fig. 1). The backpropagation equation can be applied repeatedly to \npropagate gradients through all modules, starting from the output \nat the top (where the network produces its prediction) all the way to \nthe bottom (where the external input is fed). Once these gradients \nhave been computed, it is straightforward to compute the gradients \nwith respect to the weights of each module. \nMany applications of deep learning use feedforward neural net­\nwork architectures (Fig. 1), which learn to map a fixed-size input \n(for example, an image) to a fixed-size output (for example, a prob­\nability for each of several categories). To go from one layer to the \nnext, a set of units compute a weighted sum of their inputs from the \nprevious layer and pass the result through a non-linear function. At \npresent, the most popular non-linear function is the rectified linear \nunit (ReLU), which is simply the half-wave rectifier f(z) = max(z, 0). \nIn past decades, neural nets used smoother non-linearities, such as \ntanh(z) or 1/(1 + exp(−z)), but the ReLU typically learns much faster \nin networks with many layers, allowing training of a deep supervised \nnetwork without unsupervised pre-training28. Units that are not in \nthe input or output layer are conventionally called hidden units. The \nhidden layers can be seen as distorting the input in a non-linear way \nso that categories become linearly separable by the last layer (Fig. 1). \nIn the late 1990s, neural nets and backpropagation were largely \nforsaken by the machine-learning community and ignored by the \ncomputer-vision and speech-recognition communities. It was widely \nthought that learning useful, multistage, feature extractors with lit­\ntle prior knowledge was infeasible. In particular, it was commonly \nthought that simple gradient descent would get trapped in poor local \nminima — weight configurations for which no small change would \nreduce the average error. \nIn practice, poor local minima are rarely a problem with large net­\nworks. Regardless of the initial conditions, the system nearly always \nreaches solutions of very similar quality. Recent theoretical and \nempirical results strongly suggest that local minima are not a serious \nissue in general. Instead, the landscape is packed with a combinato­\nrially large number of saddle points where the gradient is zero, and \nthe surface curves up in most dimensions and curves down in the \nFigure 2 | Inside a convolutional network.  The outputs (not the filters) \nof each layer (horizontally) of a typical convolutional network architecture \napplied to the image of a Samoyed dog (bottom left; and RGB (red, green, \nblue) inputs, bottom right). Each rectangular image is a feature map \ncorresponding to the output for one of the learned features, detected at each \nof the image positions. Information flows bottom up, with lower-level features \nacting as oriented edge detectors, and a score is computed for each image class \nin output. ReLU, rectified linear unit.\nRed\nGreen\nBlue\nSamoyed (16); Papillon (5.7); Pomeranian (2.7); Arctic fox (1.0); Eskimo dog (0.6); white wolf (0.4); Siberian husky (0.4)\nConvolutions and ReLU\nMax pooling\nMax pooling\nConvolutions and ReLU\nConvolutions and ReLU\n4 3 8  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nremainder29,30. The analysis seems to show that saddle points with \nonly a few downward curving directions are present in very large \nnumbers, but almost all of them have very similar values of the objec­\ntive function. Hence, it does not much matter which of these saddle \npoints the algorithm gets stuck at. \nInterest in deep feedforward networks was revived around 2006 \n(refs 31–34) by a group of researchers brought together by the Cana­\ndian Institute for Advanced Research (CIFAR). The researchers intro­\nduced unsupervised learning procedures that could create layers of \nfeature detectors without requiring labelled data. The objective in \nlearning each layer of feature detectors was to be able to reconstruct \nor model the activities of feature detectors (or raw inputs) in the layer \nbelow. By ‘pre-training’ several layers of progressively more complex \nfeature detectors using this reconstruction objective, the weights of a \ndeep network could be initialized to sensible values. A final layer of \noutput units could then be added to the top of the network and the \nwhole deep system could be fine-tuned using standard backpropaga­\ntion33–35. This worked remarkably well for recognizing handwritten \ndigits or for detecting pedestrians, especially when the amount of \nlabelled data was very limited36. \nThe first major application of this pre-training approach was in \nspeech recognition, and it was made possible by the advent of fast \ngraphics processing units (GPUs) that were convenient to program37 \nand allowed researchers to train networks 10 or 20 times faster. In \n2009, the approach was used to map short temporal windows of coef­\nficients extracted from a sound wave to a set of probabilities for the \nvarious fragments of speech that might be represented by the frame \nin the centre of the window. It achieved record-breaking results on a \nstandard speech recognition benchmark that used a small vocabu­\nlary38 and was quickly developed to give record-breaking results on \na large vocabulary task39. By 2012, versions of the deep net from 2009 \nwere being developed by many of the major speech groups6 and were \nalready being deployed in Android phones. For smaller data sets, \nunsupervised pre-training helps to prevent overfitting40, leading to \nsignificantly better generalization when the number of labelled exam­\nples is small, or in a transfer setting where we have lots of examples \nfor some ‘source’ tasks but very few for some ‘target’ tasks. Once deep \nlearning had been rehabilitated, it turned out that the pre-training \nstage was only needed for small data sets. \nThere was, however, one particular type of deep, feedforward net­\nwork that was much easier to train and generalized much better than \nnetworks with full connectivity between adjacent layers. This was \nthe convolutional neural network (ConvNet)41,42. It achieved many \npractical successes during the period when neural networks were out \nof favour and it has recently been widely adopted by the computer-\nvision community. \nConvolutional neural networks \nConvNets are designed to process data that come in the form of \nmultiple arrays, for example a colour image composed of three 2D \narrays containing pixel intensities in the three colour channels. Many \ndata modalities are in the form of multiple arrays: 1D for signals and \nsequences, including language; 2D for images or audio spectrograms; \nand 3D for video or volumetric images. There are four key ideas \nbehind ConvNets that take advantage of the properties of natural \nsignals: local connections, shared weights, pooling and the use of \nmany layers. \nThe architecture of a typical ConvNet (Fig. 2) is structured as a \nseries of stages. The first few stages are composed of two types of \nlayers: convolutional layers and pooling layers. Units in a convolu­\ntional layer are organized in feature maps, within which each unit \nis connected to local patches in the feature maps of the previous \nlayer through a set of weights called a filter bank. The result of this \nlocal weighted sum is then passed through a non-linearity such as a \nReLU. All units in a feature map share the same filter bank. Differ­\nent feature maps in a layer use different filter banks. The reason for \nthis architecture is twofold. First, in array data such as images, local \ngroups of values are often highly correlated, forming distinctive local \nmotifs that are easily detected. Second, the local statistics of images \nand other signals are invariant to location. In other words, if a motif \ncan appear in one part of the image, it could appear anywhere, hence \nthe idea of units at different locations sharing the same weights and \ndetecting the same pattern in different parts of the array. Mathemati­\ncally, the filtering operation performed by a feature map is a discrete \nconvolution, hence the name. \nAlthough the role of the convolutional layer is to detect local con­\njunctions of features from the previous layer, the role of the pooling \nlayer is to merge semantically similar features into one. Because the \nrelative positions of the features forming a motif can vary somewhat, \nreliably detecting the motif can be done by coarse-graining the posi­\ntion of each feature. A typical pooling unit computes the maximum \nof a local patch of units in one feature map (or in a few feature maps). \nNeighbouring pooling units take input from patches that are shifted \nby more than one row or column, thereby reducing the dimension of \nthe representation and creating an invariance to small shifts and dis­\ntortions. Two or three stages of convolution, non-linearity and pool­\ning are stacked, followed by more convolutional and fully-connected \nlayers. Backpropagating gradients through a ConvNet is as simple as \nthrough a regular deep network, allowing all the weights in all the \nfilter banks to be trained. \nDeep neural networks exploit the property that many natural sig­\nnals are compositional hierarchies, in which higher-level features \nare obtained by composing lower-level ones. In images, local combi­\nnations of edges form motifs, motifs assemble into parts, and parts \nform objects. Similar hierarchies exist in speech and text from sounds \nto phones, phonemes, syllables, words and sentences. The pooling \nallows representations to vary very little when elements in the previ­\nous layer vary in position and appearance. \nThe convolutional and pooling layers in ConvNets are directly \ninspired by the classic notions of simple cells and complex cells in \nvisual neuroscience43, and the overall architecture is reminiscent of \nthe LGN–V1–V2–V4–IT hierarchy in the visual cortex ventral path­\nway44. When ConvNet models and monkeys are shown the same pic­\nture, the activations of high-level units in the ConvNet explains half \nof the variance of random sets of 160 neurons in the monkey’s infer­\notemporal cortex45. ConvNets have their roots in the neocognitron46, \nthe architecture of which was somewhat similar, but did not have an \nend-to-end supervised-learning algorithm such as backpropagation. \nA primitive 1D ConvNet called a time-delay neural net was used for \nthe recognition of phonemes and simple words47,48. \nThere have been numerous applications of convolutional net­\nworks going back to the early 1990s, starting with time-delay neu­\nral networks for speech recognition47 and document reading42. The \ndocument reading system used a ConvNet trained jointly with a \nprobabilistic model that implemented language constraints. By the \nlate 1990s this system was reading over 10% of all the cheques in the \nUnited States. A number of ConvNet-based optical character recog­\nnition and handwriting recognition systems were later deployed by \nMicrosoft49. ConvNets were also experimented with in the early 1990s \nfor object detection in natural images, including faces and hands50,51, \nand for face recognition52. \nImage understanding with deep convolutional networks \nSince the early 2000s, ConvNets have been applied with great success to \nthe detection, segmentation and recognition of objects and regions in \nimages. These were all tasks in which labelled data was relatively abun­\ndant, such as traffic sign recognition53, the segmentation of biological \nimages54 particularly for connectomics55, and the detection of faces, \ntext, pedestrians and human bodies in natural images36,50,51,56–58. A major \nrecent practical success of ConvNets is face recognition59. \nImportantly, images can be labelled at the pixel level, which will have \napplications in technology, including autonomous mobile robots and \n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 3 9\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nself-driving cars60,61. Companies such as Mobileye and NVIDIA are \nusing such ConvNet-based methods in their upcoming vision sys­\ntems for cars. Other applications gaining importance involve natural \nlanguage understanding14 and speech recognition7. \nDespite these successes, ConvNets were largely forsaken by the \nmainstream computer-vision and machine-learning communities \nuntil the ImageNet competition in 2012. When deep convolutional \nnetworks were applied to a data set of about a million images from \nthe web that contained 1,000 different classes, they achieved spec­\ntacular results, almost halving the error rates of the best compet­\ning approaches1. This success came from the efficient use of GPUs, \nReLUs, a new regularization technique called dropout62, and tech­\nniques to generate more training examples by deforming the existing \nones. This success has brought about a revolution in computer vision; \nConvNets are now the dominant approach for almost all recognition \nand detection tasks4,58,59,63–65 and approach human performance on \nsome tasks. A recent stunning demonstration combines ConvNets \nand recurrent net modules for the generation of image captions \n(Fig. 3). \nRecent ConvNet architectures have 10 to 20 layers of ReLUs, hun­\ndreds of millions of weights, and billions of connections between \nunits. Whereas training such large networks could have taken weeks \nonly two years ago, progress in hardware, software and algorithm \nparallelization have reduced training times to a few hours. \nThe performance of ConvNet-based vision systems has caused \nmost major technology companies, including Google, Facebook, \nMicrosoft, IBM, Yahoo!, Twitter and Adobe, as well as a quickly \ngrowing number of start-ups to initiate research and development \nprojects and to deploy ConvNet-based image understanding products \nand services. \nConvNets are easily amenable to efficient hardware implemen­\ntations in chips or field-programmable gate arrays66,67. A number \nof companies such as NVIDIA, Mobileye, Intel, Qualcomm and \nSamsung are developing ConvNet chips to enable real-time vision \napplications in smartphones, cameras, robots and self-driving cars. \nDistributed representations and language processing \nDeep-learning theory shows that deep nets have two different expo­\nnential advantages over classic learning algorithms that do not use \ndistributed representations21. Both of these advantages arise from the \npower of composition and depend on the underlying data-generating \ndistribution having an appropriate componential structure40. First, \nlearning distributed representations enable generalization to new \ncombinations of the values of learned features beyond those seen \nduring training (for example, 2n combinations are possible with n \nbinary features)68,69. Second, composing layers of representation in \na deep net brings the potential for another exponential advantage70 \n(exponential in the depth). \nThe hidden layers of a multilayer neural network learn to repre­\nsent the network’s inputs in a way that makes it easy to predict the \ntarget outputs. This is nicely demonstrated by training a multilayer \nneural network to predict the next word in a sequence from a local \nFigure 3 | From image to text.  Captions generated by a recurrent neural \nnetwork (RNN) taking, as extra input, the representation extracted by a deep \nconvolution neural network (CNN) from a test image, with the RNN trained to \n‘translate’ high-level representations of images into captions (top). Reproduced \nwith permission from ref. 102. When the RNN is given the ability to focus its \nattention on a different location in the input image (middle and bottom; the \nlighter patches were given more attention) as it generates each word (bold), we \nfound86 that it exploits this to achieve better ‘translation’ of images into captions.\nVision\nDeep CNN\nLanguage\nGenerating RNN\nA group of people \nshopping at an outdoor \nmarket.\nThere are many \nvegetables at the \nfruit stand.\nA woman is throwing a frisbee in a park.\nA little girl sitting on a bed with a teddy bear.\nA group of people sitting on a boat in the water.\nA giraﬀe standing in a forest with\ntrees in the background.\nA dog is standing on a hardwood ﬂoor.\nA stop sign is on a road with a\nmountain in the background\n4 4 0  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\ncontext of earlier words71. Each word in the context is presented to \nthe network as a one-of-N vector, that is, one component has a value \nof 1 and the rest are 0. In the first layer, each word creates a different \npattern of activations, or word vectors (Fig. 4). In a language model, \nthe other layers of the network learn to convert the input word vec­\ntors into an output word vector for the predicted next word, which \ncan be used to predict the probability for any word in the vocabulary \nto appear as the next word. The network learns word vectors that \ncontain many active components each of which can be interpreted \nas a separate feature of the word, as was first demonstrated27 in the \ncontext of learning distributed representations for symbols. These \nsemantic features were not explicitly present in the input. They were \ndiscovered by the learning procedure as a good way of factorizing \nthe structured relationships between the input and output symbols \ninto multiple ‘micro-rules’. Learning word vectors turned out to also \nwork very well when the word sequences come from a large corpus \nof real text and the individual micro-rules are unreliable71. When \ntrained to predict the next word in a news story, for example, the \nlearned word vectors for Tuesday and Wednesday are very similar, as \nare the word vectors for Sweden and Norway. Such representations \nare called distributed representations because their elements (the \nfeatures) are not mutually exclusive and their many configurations \ncorrespond to the variations seen in the observed data. These word \nvectors are composed of learned features that were not determined \nahead of time by experts, but automatically discovered by the neural \nnetwork. Vector representations of words learned from text are now \nvery widely used in natural language applications14,17,72–76. \nThe issue of representation lies at the heart of the debate between \nthe logic-inspired and the neural-network-inspired paradigms for \ncognition. In the logic-inspired paradigm, an instance of a symbol is \nsomething for which the only property is that it is either identical or \nnon-identical to other symbol instances. It has no internal structure \nthat is relevant to its use; and to reason with symbols, they must be \nbound to the variables in judiciously chosen rules of inference. By \ncontrast, neural networks just use big activity vectors, big weight \nmatrices and scalar non-linearities to perform the type of fast ‘intui­\ntive’ inference that underpins effortless commonsense reasoning. \nBefore the introduction of neural language models71, the standard \napproach to statistical modelling of language did not exploit distrib­\nuted representations: it was based on counting frequencies of occur­\nrences of short symbol sequences of length up to N (called N-grams). \nThe number of possible N-grams is on the order of VN, where V is \nthe vocabulary size, so taking into account a context of more than a \nhandful of words would require very large training corpora. N-grams \ntreat each word as an atomic unit, so they cannot generalize across \nsemantically related sequences of words, whereas neural language \nmodels can because they associate each word with a vector of real \nvalued features, and semantically related words end up close to each \nother in that vector space (Fig. 4). \nRecurrent neural networks \nWhen backpropagation was first introduced, its most exciting use was \nfor training recurrent neural networks (RNNs). For tasks that involve \nsequential inputs, such as speech and language, it is often better to \nuse RNNs (Fig. 5). RNNs process an input sequence one element at a \ntime, maintaining in their hidden units a ‘state vector’ that implicitly \ncontains information about the history of all the past elements of \nthe sequence. When we consider the outputs of the hidden units at \ndifferent discrete time steps as if they were the outputs of different \nneurons in a deep multilayer network (Fig. 5, right), it becomes clear \nhow we can apply backpropagation to train RNNs. \nRNNs are very powerful dynamic systems, but training them has \nproved to be problematic because the backpropagated gradients \neither grow or shrink at each time step, so over many time steps they \ntypically explode or vanish77,78. \nThanks to advances in their architecture79,80 and ways of training \nthem81,82, RNNs have been found to be very good at predicting the \nnext character in the text83 or the next word in a sequence75, but they \ncan also be used for more complex tasks. For example, after reading \nan English sentence one word at a time, an English ‘encoder’ network \ncan be trained so that the final state vector of its hidden units is a good \nrepresentation of the thought expressed by the sentence. This thought \nvector can then be used as the initial hidden state of (or as extra input \nto) a jointly trained French ‘decoder’ network, which outputs a prob­\nability distribution for the first word of the French translation. If a \nparticular first word is chosen from this distribution and provided \nas input to the decoder network it will then output a probability dis­\ntribution for the second word of the translation and so on until a \nfull stop is chosen17,72,76. Overall, this process generates sequences of \nFrench words according to a probability distribution that depends on \nthe English sentence. This rather naive way of performing machine \ntranslation has quickly become competitive with the state-of-the-art, \nand this raises serious doubts about whether understanding a sen­\ntence requires anything like the internal symbolic expressions that are \nmanipulated by using inference rules. It is more compatible with the \nview that everyday reasoning involves many simultaneous analogies \nFigure 4 | Visualizing the learned word vectors.  On the left is an illustration \nof word representations learned for modelling language, non-linearly projected \nto 2D for visualization using the t-SNE algorithm103. On the right is a 2D \nrepresentation of phrases learned by an English-to-French encoder–decoder \nrecurrent neural network75. One can observe that semantically similar words \nor sequences of words are mapped to nearby representations. The distributed \nrepresentations of words are obtained by using backpropagation to jointly learn \na representation for each word and a function that predicts a target quantity \nsuch as the next word in a sequence (for language modelling) or a whole \nsequence of translated words (for machine translation)18,75.\n−37\n−36\n−35\n−34\n−33\n−32\n−31\n−30\n−29\n9\n10\n10.5\n11\n11.5\n12\n12.5\n13\n13.5\n14\n community\n organizations  institutions\n society\n industry\n company\n organization\n school\n companies\n Community\n oﬃce\n Agency\n communities\n Association\n body\n schools\n agencies\n−5.5\n−5\n−4.5\n−4\n−3.5\n−3\n−2.5\n−2\n−4.2\n−4\n−3.8\n−3.6\n−3.4\n−3.2\n−3\n−2.8\n−2.6\n−2.4\n−2.2\nover the past few months\nthat a few days\nIn the last few days\nthe past few days\nIn a few months\nin the coming months\na few months ago\n&quot; the two groups\nof the two groups\nover the last few months\ndispute between the two\nthe last two decades\nthe next six months\ntwo months before being\nfor nearly two months\nover the last two decades\nwithin a few months\n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 4 1\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nthat each contribute plausibility to a conclusion84,85. \nInstead of translating the meaning of a French sentence into an \nEnglish sentence, one can learn to ‘translate’ the meaning of an image \ninto an English sentence (Fig. 3). The encoder here is a deep Con­\nvNet that converts the pixels into an activity vector in its last hidden \nlayer. The decoder is an RNN similar to the ones used for machine \ntranslation and neural language modelling. There has been a surge of \ninterest in such systems recently (see examples mentioned in ref. 86). \nRNNs, once unfolded in time (Fig. 5), can be seen as very deep \nfeedforward networks in which all the layers share the same weights. \nAlthough their main purpose is to learn long-term dependencies, \ntheoretical and empirical evidence shows that it is difficult to learn \nto store information for very long78.  \nTo correct for that, one idea is to augment the network with an \nexplicit memory. The first proposal of this kind is the long short-term \nmemory (LSTM) networks that use special hidden units, the natural \nbehaviour of which is to remember inputs for a long time79. A special \nunit called the memory cell acts like an accumulator or a gated leaky \nneuron: it has a connection to itself at the next time step that has a \nweight of one, so it copies its own real-valued state and accumulates \nthe external signal, but this self-connection is multiplicatively gated \nby another unit that learns to decide when to clear the content of the \nmemory. \nLSTM networks have subsequently proved to be more effective \nthan conventional RNNs, especially when they have several layers for \neach time step87, enabling an entire speech recognition system that \ngoes all the way from acoustics to the sequence of characters in the \ntranscription. LSTM networks or related forms of gated units are also \ncurrently used for the encoder and decoder networks that perform \nso well at machine translation17,72,76. \nOver the past year, several authors have made different proposals to \naugment RNNs with a memory module. Proposals include the Neural \nTuring Machine in which the network is augmented by a ‘tape-like’ \nmemory that the RNN can choose to read from or write to88, and \nmemory networks, in which a regular network is augmented by a \nkind of associative memory89. Memory networks have yielded excel­\nlent performance on standard question-answering benchmarks. The \nmemory is used to remember the story about which the network is \nlater asked to answer questions. \nBeyond simple memorization, neural Turing machines and mem­\nory networks are being used for tasks that would normally require \nreasoning and symbol manipulation. Neural Turing machines can \nbe taught ‘algorithms’. Among other things, they can learn to output \na sorted list of symbols when their input consists of an unsorted \nsequence in which each symbol is accompanied by a real value that \nindicates its priority in the list88. Memory networks can be trained \nto keep track of the state of the world in a setting similar to a text \nadventure game and after reading a story, they can answer questions \nthat require complex inference90. In one test example, the network is \nshown a 15-sentence version of the The Lord of the Rings and correctly \nanswers questions such as “where is Frodo now?”89.  \nThe future of deep learning \nUnsupervised learning91–98 had a catalytic effect in reviving interest in \ndeep learning, but has since been overshadowed by the successes of \npurely supervised learning. Although we have not focused on it in this \nReview, we expect unsupervised learning to become far more important \nin the longer term. Human and animal learning is largely unsupervised: \nwe discover the structure of the world by observing it, not by being told \nthe name of every object. \nHuman vision is an active process that sequentially samples the optic \narray in an intelligent, task-speciﬁc way using a small, high-resolution \nfovea with a large, low-resolution surround. We expect much of the \nfuture progress in vision to come from systems that are trained end-to-\nend and combine ConvNets with RNNs that use reinforcement learning \nto decide where to look. Systems combining deep learning and rein­\nforcement learning are in their infancy, but they already outperform \npassive vision systems99 at classification tasks and produce impressive \nresults in learning to play many different video games100. \nNatural language understanding is another area in which deep learn­\ning is poised to make a large impact over the next few years. We expect \nsystems that use RNNs to understand sentences or whole documents \nwill become much better when they learn strategies for selectively \nattending to one part at a time76,86. \nUltimately, major progress in artificial intelligence will come about \nthrough systems that combine representation learning with complex \nreasoning. Although deep learning and simple reasoning have been \nused for speech and handwriting recognition for a long time, new \nparadigms are needed to replace rule-based manipulation of symbolic \nexpressions by operations on large vectors101. ■\nReceived 25 February; accepted 1 May 2015.\n1.\t\nKrizhevsky, A., Sutskever, I. & Hinton, G. ImageNet classification with deep \nconvolutional neural networks. In Proc. Advances in Neural Information \nProcessing Systems 25 1090–1098 (2012).\n\t\nThis report was a breakthrough that used convolutional nets to almost halve \nthe error rate for object recognition, and precipitated the rapid adoption of \ndeep learning by the computer vision community.\n2.\t\nFarabet, C., Couprie, C., Najman, L. & LeCun, Y. Learning hierarchical features for \nscene labeling. IEEE Trans. Pattern Anal. Mach. Intell. 35, 1915–1929 (2013). \n3.\t\nTompson, J., Jain, A., LeCun, Y. & Bregler, C. Joint training of a convolutional \nnetwork and a graphical model for human pose estimation. In Proc. Advances in \nNeural Information Processing Systems 27 1799–1807 (2014). \n4.\t\nSzegedy, C. et al. Going deeper with convolutions. Preprint at http://arxiv.org/\nabs/1409.4842 (2014). \n5.\t\nMikolov, T., Deoras, A., Povey, D., Burget, L. & Cernocky, J. Strategies for training \nlarge scale neural network language models. In Proc. Automatic Speech \nRecognition and Understanding 196–201 (2011). \n6.\t\nHinton, G. et al. Deep neural networks for acoustic modeling in speech \nrecognition. IEEE Signal Processing Magazine 29, 82–97 (2012).\n\t\nThis joint paper from the major speech recognition laboratories, summarizing \nthe breakthrough achieved with deep learning on the task of phonetic \nclassification for automatic speech recognition, was the first major industrial \napplication of deep learning.\n7.\t\nSainath, T., Mohamed, A.-R., Kingsbury, B. & Ramabhadran, B. Deep \nconvolutional neural networks for LVCSR. In Proc. Acoustics, Speech and Signal \nProcessing 8614–8618 (2013). \n8.\t\nMa, J., Sheridan, R. P., Liaw, A., Dahl, G. E. & Svetnik, V. Deep neural nets as a \nmethod for quantitative structure-activity relationships. J. Chem. Inf. Model. 55, \n263–274 (2015). \n9.\t\nCiodaro, T., Deva, D., de Seixas, J. & Damazio, D. Online particle detection with \nneural networks based on topological calorimetry information. J. Phys. Conf. \nSeries 368, 012030 (2012). \n10.\t Kaggle. Higgs boson machine learning challenge. Kaggle https://www.kaggle.\ncom/c/higgs-boson (2014). \n11.\t Helmstaedter, M. et al. Connectomic reconstruction of the inner plexiform layer \nin the mouse retina. Nature 500, 168–174 (2013). \nxt\nxt−1\nxt+1\nx\nUnfold\nV\nW\nW\nW\nW\nW\nV\nV\nV\nU\nU\nU\nU\ns\no\nst−1\not−1\not\nst\nst+1\not+1\nFigure 5 | A recurrent neural network and the unfolding in time of the \ncomputation involved in its forward computation.  The artificial neurons \n(for example, hidden units grouped under node s with values st at time t) get \ninputs from other neurons at previous time steps (this is represented with the \nblack square, representing a delay of one time step, on the left). In this way, a \nrecurrent neural network can map an input sequence with elements xt into an \noutput sequence with elements ot, with each ot depending on all the previous \nxtʹ (for tʹ ≤ t). The same parameters (matrices U,V,W ) are used at each time \nstep. Many other architectures are possible, including a variant in which the \nnetwork can generate a sequence of outputs (for example, words), each of \nwhich is used as inputs for the next time step. The backpropagation algorithm \n(Fig. 1) can be directly applied to the computational graph of the unfolded \nnetwork on the right, to compute the derivative of a total error (for example, \nthe log-probability of generating the right sequence of outputs) with respect to \nall the states st and all the parameters.\n4 4 2  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\n12.\t Leung, M. K., Xiong, H. Y., Lee, L. J. & Frey, B. J. Deep learning of the tissue-\nregulated splicing code. Bioinformatics 30, i121–i129 (2014). \n13.\t Xiong, H. Y. et al. The human splicing code reveals new insights into the genetic \ndeterminants of disease. Science 347, 6218 (2015). \n14.\t Collobert, R., et al. Natural language processing (almost) from scratch. J. Mach. \nLearn. Res. 12, 2493–2537 (2011). \n15.\t Bordes, A., Chopra, S. & Weston, J. Question answering with subgraph \nembeddings. In Proc. Empirical Methods in Natural Language Processing http://\narxiv.org/abs/1406.3676v3 (2014). \n16.\t Jean, S., Cho, K., Memisevic, R. & Bengio, Y. On using very large target \nvocabulary for neural machine translation. In Proc. ACL-IJCNLP http://arxiv.org/\nabs/1412.2007 (2015).\n17.\t Sutskever, I. Vinyals, O. & Le. Q. V. Sequence to sequence learning with neural \nnetworks. In Proc. Advances in Neural Information Processing Systems 27 \n3104–3112 (2014). \n\t\nThis paper showed state-of-the-art machine translation results with the \narchitecture introduced in ref. 72, with a recurrent network trained to read a \nsentence in one language, produce a semantic representation of its meaning, \nand generate a translation in another language.\n18.\t Bottou, L. & Bousquet, O. The tradeoffs of large scale learning. In Proc. Advances \nin Neural Information Processing Systems 20 161–168 (2007). \n19.\t Duda, R. O. & Hart, P. E. Pattern Classiﬁcation and Scene Analysis (Wiley, 1973). \n20.\t Schölkopf, B. & Smola, A. Learning with Kernels (MIT Press, 2002). \n21.\t Bengio, Y., Delalleau, O. & Le Roux, N. The curse of highly variable functions \nfor local kernel machines. In Proc. Advances in Neural Information Processing \nSystems 18 107–114 (2005). \n22.\t Selfridge, O. G. Pandemonium: a paradigm for learning in mechanisation of \nthought processes. In Proc. Symposium on Mechanisation of Thought Processes \n513–526 (1958). \n23.\t Rosenblatt, F. The Perceptron — A Perceiving and Recognizing Automaton. Tech. \nRep. 85-460-1 (Cornell Aeronautical Laboratory, 1957). \n24.\t Werbos, P. Beyond Regression: New Tools for Prediction and Analysis in the \nBehavioral Sciences. PhD thesis, Harvard Univ. (1974). \n25.\t Parker, D. B. Learning Logic Report TR–47 (MIT Press, 1985). \n26.\t LeCun, Y. Une procédure d’apprentissage pour Réseau à seuil assymétrique \nin Cognitiva 85: a la Frontière de l’Intelligence Artiﬁcielle, des Sciences de la \nConnaissance et des Neurosciences [in French] 599–604 (1985). \n27.\t Rumelhart, D. E., Hinton, G. E. & Williams, R. J. Learning representations by \nback-propagating errors. Nature 323, 533–536 (1986). \n28.\t Glorot, X., Bordes, A. & Bengio. Y. Deep sparse rectiﬁer neural networks. In Proc. \n14th International Conference on Artificial Intelligence and Statistics 315–323 \n(2011). \n\t\nThis paper showed that supervised training of very deep neural networks is \nmuch faster if the hidden layers are composed of ReLU.\n29.\t Dauphin, Y. et al. Identifying and attacking the saddle point problem in high-\ndimensional non-convex optimization. In Proc. Advances in Neural Information \nProcessing Systems 27 2933–2941 (2014). \n30.\t Choromanska, A., Henaff, M., Mathieu, M., Arous, G. B. & LeCun, Y. The loss \nsurface of multilayer networks. In Proc. Conference on AI and Statistics http://\narxiv.org/abs/1412.0233 (2014). \n31.\t Hinton, G. E. What kind of graphical model is the brain? In Proc. 19th \nInternational Joint Conference on Artificial intelligence 1765–1775 (2005). \n32.\t Hinton, G. E., Osindero, S. & Teh, Y.-W. A fast learning algorithm for deep belief \nnets. Neural Comp. 18, 1527–1554 (2006).\n\t\nThis paper introduced a novel and effective way of training very deep neural \nnetworks by pre-training one hidden layer at a time using the unsupervised \nlearning procedure for restricted Boltzmann machines. \n33.\t Bengio, Y., Lamblin, P., Popovici, D. & Larochelle, H. Greedy layer-wise training \nof deep networks. In Proc. Advances in Neural Information Processing Systems 19 \n153–160 (2006). \n\t\nThis report demonstrated that the unsupervised pre-training method \nintroduced in ref. 32 significantly improves performance on test data and \ngeneralizes the method to other unsupervised representation-learning \ntechniques, such as auto-encoders.\n34.\t Ranzato, M., Poultney, C., Chopra, S. & LeCun, Y. Efﬁcient learning of sparse \nrepresentations with an energy-based model. In Proc. Advances in Neural \nInformation Processing Systems 19 1137–1144 (2006). \n35.\t Hinton, G. E. & Salakhutdinov, R. Reducing the dimensionality of data with \nneural networks. Science 313, 504–507 (2006). \n36.\t Sermanet, P., Kavukcuoglu, K., Chintala, S. & LeCun, Y. Pedestrian detection with \nunsupervised multi-stage feature learning. In Proc. International Conference \non Computer Vision and Pattern Recognition http://arxiv.org/abs/1212.0142 \n(2013). \n37.\t Raina, R., Madhavan, A. & Ng, A. Y. Large-scale deep unsupervised learning \nusing graphics processors. In Proc. 26th Annual International Conference on \nMachine Learning 873–880 (2009). \n38.\t Mohamed, A.-R., Dahl, G. E. & Hinton, G. Acoustic modeling using deep belief \nnetworks. IEEE Trans. Audio Speech Lang. Process. 20, 14–22 (2012). \n39.\t Dahl, G. E., Yu, D., Deng, L. & Acero, A. Context-dependent pre-trained deep \nneural networks for large vocabulary speech recognition. IEEE Trans. Audio \nSpeech Lang. Process. 20, 33–42 (2012). \n40.\t Bengio, Y., Courville, A. & Vincent, P. Representation learning: a review and new \nperspectives. IEEE Trans. Pattern Anal. Machine Intell. 35, 1798–1828 (2013). \n41.\t LeCun, Y. et al. Handwritten digit recognition with a back-propagation network. \nIn Proc. Advances in Neural Information Processing Systems 396–404 (1990). \n\t\nThis is the first paper on convolutional networks trained by backpropagation \nfor the task of classifying low-resolution images of handwritten digits.\n42.\t LeCun, Y., Bottou, L., Bengio, Y. & Haffner, P. Gradient-based learning applied to \ndocument recognition. Proc. IEEE 86, 2278–2324 (1998). \n\t\nThis overview paper on the principles of end-to-end training of modular \nsystems such as deep neural networks using gradient-based optimization \nshowed how neural networks (and in particular convolutional nets) can be \ncombined with search or inference mechanisms to model complex outputs \nthat are interdependent, such as sequences of characters associated with the \ncontent of a document.\n43.\t Hubel, D. H. & Wiesel, T. N. Receptive ﬁelds, binocular interaction, and functional \narchitecture in the cat’s visual cortex. J. Physiol. 160, 106–154 (1962). \n44.\t Felleman, D. J. & Essen, D. C. V. Distributed hierarchical processing in the \nprimate cerebral cortex. Cereb. Cortex 1, 1–47 (1991). \n45.\t Cadieu, C. F. et al. Deep neural networks rival the representation of primate \nit cortex for core visual object recognition. PLoS Comp. Biol. 10, e1003963 \n(2014). \n46.\t Fukushima, K. & Miyake, S. Neocognitron: a new algorithm for pattern \nrecognition tolerant of deformations and shifts in position. Pattern Recognition \n15, 455–469 (1982). \n47.\t Waibel, A., Hanazawa, T., Hinton, G. E., Shikano, K. & Lang, K. Phoneme \nrecognition using time-delay neural networks. IEEE Trans. Acoustics Speech \nSignal Process. 37, 328–339 (1989). \n48.\t Bottou, L., Fogelman-Soulié, F., Blanchet, P. & Lienard, J. Experiments with time \ndelay networks and dynamic time warping for speaker independent isolated \ndigit recognition. In Proc. EuroSpeech 89 537–540 (1989). \n49.\t Simard, D., Steinkraus, P. Y. & Platt, J. C. Best practices for convolutional neural \nnetworks. In Proc. Document Analysis and Recognition 958–963 (2003). \n50.\t Vaillant, R., Monrocq, C. & LeCun, Y. Original approach for the localisation of \nobjects in images. In Proc. Vision, Image, and Signal Processing 141, 245–250 \n(1994). \n51.\t Nowlan, S. & Platt, J. in Neural Information Processing Systems 901–908 (1995). \n52.\t Lawrence, S., Giles, C. L., Tsoi, A. C. & Back, A. D. Face recognition: a \nconvolutional neural-network approach. IEEE Trans. Neural Networks 8, 98–113 \n(1997). \n53.\t Ciresan, D., Meier, U. Masci, J. & Schmidhuber, J. Multi-column deep neural \nnetwork for trafﬁc sign classiﬁcation. Neural Networks 32, 333–338 (2012). \n54.\t Ning, F. et al. Toward automatic phenotyping of developing embryos from \nvideos. IEEE Trans. Image Process. 14, 1360–1371 (2005). \n55.\t Turaga, S. C. et al. Convolutional networks can learn to generate afﬁnity graphs \nfor image segmentation. Neural Comput. 22, 511–538 (2010). \n56.\t Garcia, C. & Delakis, M. Convolutional face ﬁnder: a neural architecture for \nfast and robust face detection. IEEE Trans. Pattern Anal. Machine Intell. 26, \n1408–1423 (2004). \n57.\t Osadchy, M., LeCun, Y. & Miller, M. Synergistic face detection and pose \nestimation with energy-based models. J. Mach. Learn. Res. 8, 1197–1215 \n(2007). \n58.\t Tompson, J., Goroshin, R. R., Jain, A., LeCun, Y. Y. & Bregler, C. C. Efﬁcient object \nlocalization using convolutional networks. In Proc. Conference on Computer \nVision and Pattern Recognition http://arxiv.org/abs/1411.4280 (2014). \n59.\t Taigman, Y., Yang, M., Ranzato, M. & Wolf, L. Deepface: closing the gap to \nhuman-level performance in face veriﬁcation. In Proc. Conference on Computer \nVision and Pattern Recognition 1701–1708 (2014). \n60.\t Hadsell, R. et al. Learning long-range vision for autonomous off-road driving. \nJ. Field Robot. 26, 120–144 (2009). \n61.\t Farabet, C., Couprie, C., Najman, L. & LeCun, Y. Scene parsing with multiscale \nfeature learning, purity trees, and optimal covers. In Proc. International \nConference on Machine Learning http://arxiv.org/abs/1202.2160 (2012). \n62.\t Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I. & Salakhutdinov, R. \nDropout: a simple way to prevent neural networks from overﬁtting. J. Machine \nLearning Res. 15, 1929–1958 (2014). \n63.\t Sermanet, P. et al. Overfeat: integrated recognition, localization and detection \nusing convolutional networks. In Proc. International Conference on Learning \nRepresentations http://arxiv.org/abs/1312.6229 (2014). \n64.\t Girshick, R., Donahue, J., Darrell, T. & Malik, J. Rich feature hierarchies for \naccurate object detection and semantic segmentation. In Proc. Conference on \nComputer Vision and Pattern Recognition 580–587 (2014). \n65.\t Simonyan, K. & Zisserman, A. Very deep convolutional networks for large-scale \nimage recognition. In Proc. International Conference on Learning Representations \nhttp://arxiv.org/abs/1409.1556 (2014). \n66.\t Boser, B., Sackinger, E., Bromley, J., LeCun, Y. & Jackel, L. An analog neural \nnetwork processor with programmable topology. J. Solid State Circuits 26, \n2017–2025 (1991). \n67.\t Farabet, C. et al. Large-scale FPGA-based convolutional networks. In Scaling \nup Machine Learning: Parallel and Distributed Approaches (eds Bekkerman, R., \nBilenko, M. & Langford, J.) 399–419 (Cambridge Univ. Press, 2011). \n68.\t Bengio, Y. Learning Deep Architectures for AI (Now, 2009). \n69.\t Montufar, G. & Morton, J. When does a mixture of products contain a product of \nmixtures? J. Discrete Math. 29, 321–347 (2014). \n70.\t Montufar, G. F., Pascanu, R., Cho, K. & Bengio, Y. On the number of linear regions \nof deep neural networks. In Proc. Advances in Neural Information Processing \nSystems 27 2924–2932 (2014). \n71.\t Bengio, Y., Ducharme, R. & Vincent, P. A neural probabilistic language model. In \nProc. Advances in Neural Information Processing Systems 13 932–938 (2001). \n\t\nThis paper introduced neural language models, which learn to convert a word \nsymbol into a word vector or word embedding composed of learned semantic \nfeatures in order to predict the next word in a sequence.\n72.\t Cho, K. et al. Learning phrase representations using RNN encoder-decoder \n2 8  M A Y  2 0 1 5  |  V O L  5 2 1  |  N A T U R E  |  4 4 3\nREVIEW INSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n\n\nfor statistical machine translation. In Proc. Conference on Empirical Methods in \nNatural Language Processing 1724–1734 (2014).  \n73.\t Schwenk, H. Continuous space language models. Computer Speech Lang. 21, \n492–518 (2007). \n74.\t Socher, R., Lin, C. C-Y., Manning, C. & Ng, A. Y. Parsing natural scenes and \nnatural language with recursive neural networks. In Proc. International \nConference on Machine Learning 129–136 (2011). \n75.\t Mikolov, T., Sutskever, I., Chen, K., Corrado, G. & Dean, J. Distributed \nrepresentations of words and phrases and their compositionality. In Proc. \nAdvances in Neural Information Processing Systems 26 3111–3119 (2013). \n76.\t Bahdanau, D., Cho, K. & Bengio, Y. Neural machine translation by jointly \nlearning to align and translate. In Proc. International Conference on Learning \nRepresentations http://arxiv.org/abs/1409.0473 (2015).\n77.\t Hochreiter, S. Untersuchungen zu dynamischen neuronalen Netzen [in \nGerman] Diploma thesis, T.U. Münich (1991). \n78.\t Bengio, Y., Simard, P. & Frasconi, P. Learning long-term dependencies with \ngradient descent is difﬁcult. IEEE Trans. Neural Networks 5, 157–166 (1994). \n79.\t Hochreiter, S. & Schmidhuber, J. Long short-term memory. Neural Comput. 9, \n1735–1780 (1997). \n\t\nThis paper introduced LSTM recurrent networks, which have become a crucial \ningredient in recent advances with recurrent networks because they are good \nat learning long-range dependencies. \n80.\t ElHihi, S. & Bengio, Y. Hierarchical recurrent neural networks for long-term \ndependencies. In Proc. Advances in Neural Information Processing Systems 8 \nhttp://papers.nips.cc/paper/1102-hierarchical-recurrent-neural-networks-for-\nlong-term-dependencies (1995). \n81.\t Sutskever, I. Training Recurrent Neural Networks. PhD thesis, Univ. Toronto \n(2012). \n82.\t Pascanu, R., Mikolov, T. & Bengio, Y. On the difﬁculty of training recurrent neural \nnetworks. In Proc. 30th International Conference on Machine Learning 1310–\n1318 (2013). \n83.\t Sutskever, I., Martens, J. & Hinton, G. E. Generating text with recurrent neural \nnetworks. In Proc. 28th International Conference on Machine Learning 1017–\n1024 (2011). \n84.\t Lakoff, G. & Johnson, M. Metaphors We Live By (Univ. Chicago Press, 2008). \n85.\t Rogers, T. T. & McClelland, J. L. Semantic Cognition: A Parallel Distributed \nProcessing Approach (MIT Press, 2004). \n86.\t Xu, K. et al. Show, attend and tell: Neural image caption generation with visual \nattention. In Proc. International Conference on Learning Representations http://\narxiv.org/abs/1502.03044 (2015). \n87.\t Graves, A., Mohamed, A.-R. & Hinton, G. Speech recognition with deep recurrent \nneural networks. In Proc. International Conference on Acoustics, Speech and \nSignal Processing 6645–6649 (2013). \n88.\t Graves, A., Wayne, G. & Danihelka, I. Neural Turing machines. http://arxiv.org/\nabs/1410.5401 (2014). \n89.\t Weston, J. Chopra, S. & Bordes, A. Memory networks. http://arxiv.org/\nabs/1410.3916 (2014). \n90.\t Weston, J., Bordes, A., Chopra, S. & Mikolov, T. Towards AI-complete question \nanswering: a set of prerequisite toy tasks. http://arxiv.org/abs/1502.05698 \n(2015). \n91.\t Hinton, G. E., Dayan, P., Frey, B. J. & Neal, R. M. The wake-sleep algorithm for \nunsupervised neural networks. Science 268, 1558–1161 (1995). \n92.\t Salakhutdinov, R. & Hinton, G. Deep Boltzmann machines. In Proc. International \nConference on Artificial Intelligence and Statistics 448–455 (2009). \n93.\t Vincent, P., Larochelle, H., Bengio, Y. & Manzagol, P.-A. Extracting and composing \nrobust features with denoising autoencoders. In Proc. 25th International \nConference on Machine Learning 1096–1103 (2008). \n94.\t Kavukcuoglu, K. et al. Learning convolutional feature hierarchies for visual \nrecognition. In Proc. Advances in Neural Information Processing Systems 23 \n1090–1098 (2010). \n95.\t Gregor, K. & LeCun, Y. Learning fast approximations of sparse coding. In Proc. \nInternational Conference on Machine Learning 399–406 (2010). \n96.\t Ranzato, M., Mnih, V., Susskind, J. M. & Hinton, G. E. Modeling natural images \nusing gated MRFs. IEEE Trans. Pattern Anal. Machine Intell. 35, 2206–2222 \n(2013). \n97.\t Bengio, Y., Thibodeau-Laufer, E., Alain, G. & Yosinski, J. Deep generative \nstochastic networks trainable by backprop. In Proc. 31st International \nConference on Machine Learning 226–234 (2014). \n98.\t Kingma, D., Rezende, D., Mohamed, S. & Welling, M. Semi-supervised learning \nwith deep generative models. In Proc. Advances in Neural Information Processing \nSystems 27 3581–3589 (2014). \n99.\t Ba, J., Mnih, V. & Kavukcuoglu, K. Multiple object recognition with visual \nattention. In Proc. International Conference on Learning Representations http://\narxiv.org/abs/1412.7755 (2014). \n100.\tMnih, V. et al. Human-level control through deep reinforcement learning. Nature  \n518, 529–533 (2015).\n101.\tBottou, L. From machine learning to machine reasoning. Mach. Learn. 94, \n133–149 (2014). \n102.\tVinyals, O., Toshev, A., Bengio, S. & Erhan, D. Show and tell: a neural image \ncaption generator. In Proc. International Conference on Machine Learning http://\narxiv.org/abs/1502.03044 (2014).\n103.\tvan der Maaten, L. & Hinton, G. E. Visualizing data using t-SNE. J. Mach. Learn.\nResearch 9, 2579–2605 (2008).\nAcknowledgements The authors would like to thank the Natural Sciences and \nEngineering Research Council of Canada, the Canadian Institute For Advanced \nResearch (CIFAR), the National Science Foundation and Office of Naval Research \nfor support. Y.L. and Y.B. are CIFAR fellows.\nAuthor Information Reprints and permissions information is available at \nwww.nature.com/reprints. The authors declare no competing financial \ninterests. Readers are welcome to comment on the online version of this \npaper at go.nature.com/7cjbaa. Correspondence should be addressed to Y.L. \n(yann@cs.nyu.edu).\n4 4 4  |  N A T U R E  |  V O L  5 2 1  |  2 8  M A Y  2 0 1 5\nREVIEW\nINSIGHT\n© 2015 Macmillan Publishers Limited. All rights reserved\n"
}